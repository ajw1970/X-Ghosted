window.PanelManager.prototype.init = function () {
  this.loadState();
  this.uiElements.panelContainer = this.document.createElement('div');
  this.uiElements.panelContainer.id = 'xghosted-panel-container';
  this.uiElements.panel = this.document.createElement('div');
  this.uiElements.panel.id = 'xghosted-panel';
  this.uiElements.panelContainer.appendChild(this.uiElements.panel);
  this.document.body.appendChild(this.uiElements.panelContainer);
  if (window.xGhostedStyles) {
    if (window.xGhostedStyles.modal) {
      const modalStyleSheet = this.document.createElement('style');
      modalStyleSheet.textContent = window.xGhostedStyles.modal;
      this.document.head.appendChild(modalStyleSheet);
    }
    if (window.xGhostedStyles.panel) {
      const panelStyleSheet = this.document.createElement('style');
      panelStyleSheet.textContent = window.xGhostedStyles.panel;
      this.document.head.appendChild(panelStyleSheet);
    }
  }
  this.state.isRateLimited = this.xGhosted.state.isRateLimited;
  this.state.isPollingEnabled = this.xGhosted.state.isPollingEnabled;
  this.state.isAutoScrollingEnabled = this.xGhosted.state.isAutoScrollingEnabled;
  this.uiElements.panelContainer.style.right = this.state.panelPosition.right;
  this.uiElements.panelContainer.style.top = this.state.panelPosition.top;
  this.uiElements.panelContainer.style.left = 'auto';
  this.styleElement = this.document.createElement('style');
  this.document.head.appendChild(this.styleElement);
  this.applyPanelStyles();
  const handleStateUpdated = (e) => {
    this.state.isRateLimited = e.detail.isRateLimited;
    this.renderPanel();
  };
  const handlePollingStateUpdated = (e) => {
    this.state.isPollingEnabled = e.detail.isPollingEnabled;
    this.renderPanel();
    this.applyPanelStyles();
  };
  const handleAutoScrollingToggled = (e) => {
    this.state.isAutoScrollingEnabled = e.detail.isAutoScrollingEnabled;
    this.renderPanel();
  };
  this.document.addEventListener('xghosted:state-updated', handleStateUpdated);
  this.document.addEventListener('xghosted:polling-state-updated', handlePollingStateUpdated);
  this.document.addEventListener('xghosted:auto-scrolling-toggled', handleAutoScrollingToggled);
  this.cleanup = () => {
    this.document.removeEventListener('xghosted:state-updated', handleStateUpdated);
    this.document.removeEventListener('xghosted:polling-state-updated', handlePollingStateUpdated);
    this.document.removeEventListener('xghosted:auto-scrolling-toggled', handleAutoScrollingToggled);
  };
  if (window.preact && window.preact.h) {
    this.renderPanel();
  } else {
    this.log('Preact h not available, skipping panel render');
  }
};

window.PanelManager.prototype.saveState = function () {
  const currentState = this.storage.get('xGhostedState', {});
  const updatedState = {
    ...currentState,
    panel: {
      isPanelVisible: this.state.isPanelVisible,
      panelPosition: { ...this.state.panelPosition },
      themeMode: this.state.themeMode,
    },
  };
  this.storage.set('xGhostedState', updatedState);
  this.log('Saved panel state:', updatedState);
};

window.PanelManager.prototype.loadState = function () {
  const savedState = this.storage.get('xGhostedState', {});
  const panelState = savedState.panel || {};
  this.state.isPanelVisible = panelState.isPanelVisible ?? true;
  this.state.themeMode = ['light', 'dim', 'dark'].includes(
    panelState.themeMode
  )
    ? panelState.themeMode
    : this.state.themeMode;
  if (
    panelState.panelPosition &&
    panelState.panelPosition.right &&
    panelState.panelPosition.top
  ) {
    const panelWidth = 350;
    const panelHeight = 48;
    const windowWidth = this.document.defaultView.innerWidth;
    const windowHeight = this.document.defaultView.innerHeight;
    let right = '10px';
    if (
      typeof panelState.panelPosition.right === 'string' &&
      panelState.panelPosition.right.endsWith('px')
    ) {
      const parsedRight = parseFloat(panelState.panelPosition.right);
      if (!isNaN(parsedRight)) {
        right = `${Math.max(0, Math.min(parsedRight, windowWidth - panelWidth))}px`;
      } else {
        this.log(
          `Invalid stored right position: ${panelState.panelPosition.right}, defaulting to 10px`
        );
      }
    } else {
      this.log(
        `Invalid or missing stored right position: ${panelState.panelPosition.right}, defaulting to 10px`
      );
    }
    let top = '60px';
    if (
      typeof panelState.panelPosition.top === 'string' &&
      panelState.panelPosition.top.endsWith('px')
    ) {
      const parsedTop = parseFloat(panelState.panelPosition.top);
      if (!isNaN(parsedTop)) {
        top = `${Math.max(0, Math.min(parsedTop, windowHeight - panelHeight))}px`;
      } else {
        this.log(
          `Invalid stored top position: ${panelState.panelPosition.top}, defaulting to 60px`
        );
      }
    } else {
      this.log(
        `Invalid or missing stored top position: ${panelState.panelPosition.top}, defaulting to 60px`
      );
    }
    this.state.panelPosition.right = right;
    this.state.panelPosition.top = top;
  }
  this.log(
    `Loaded panel state: isPanelVisible=${this.state.isPanelVisible}, themeMode=${this.state.themeMode}, right=${this.state.panelPosition.right}, top=${this.state.panelPosition.top}`
  );
};

window.PanelManager.prototype.applyPanelStyles = function () {
  const position = this.state.panelPosition || {
    right: '10px',
    top: '60px',
  };
  this.styleElement.textContent = `
    button:active { transform: scale(0.95); }
    #xghosted-panel-container {
      position: fixed;
      right: ${position.right};
      top: ${position.top};
      z-index: ${this.uiElements.config.PANEL.Z_INDEX};
      cursor: move;
      border-radius: 12px;
    }
  `;
};

window.PanelManager.prototype.toggleVisibility = function (newVisibility) {
  this.state.isPanelVisible =
    typeof newVisibility === 'boolean'
      ? newVisibility
      : !this.state.isPanelVisible;
  this.saveState();
  this.renderPanel();
  this.document.dispatchEvent(
    new CustomEvent('xghosted:toggle-panel-visibility', {
      detail: { isPanelVisible: this.state.isPanelVisible },
    })
  );
};

window.PanelManager.prototype.setPanelPosition = function (position) {
  this.state.panelPosition = { ...position };
  this.saveState();
  this.log(
    `Updated panel position: right=${position.right}, top=${position.top}`
  );
};

window.PanelManager.prototype.renderPanel = function () {
  if (!this.uiElements.panel) {
    this.log('renderPanel: panel element not initialized, skipping render');
    return;
  }
  this.log(
    `renderPanel: themeMode=${this.state.themeMode}, config.THEMES=`,
    this.uiElements.config.THEMES
  );
  window.preact.render(
    window.preact.h(window.Panel, {
      state: this.state,
      config: this.uiElements.config,
      xGhosted: this.xGhosted,
      currentMode: this.state.themeMode,
      toggleThemeMode: (newMode) => this.handleModeChange(newMode),
      onStartPolling: () => this.xGhosted.handleStartPolling(),
      onStopPolling: () => this.xGhosted.handleStopPolling(),
      onEyeballClick: (href) => {
        const post = this.document.querySelector(
          `[data-xghosted-id="${href}"]`
        );
        this.xGhosted.userRequestedPostCheck(href, post);
      },
      onCopyLinks: () => this.copyLinks(),
      setPanelPosition: (position) => this.setPanelPosition(position),
    }),
    this.uiElements.panel
  );
};

window.PanelManager.prototype.updateTheme = function (newMode) {
  this.state.themeMode = newMode;
  this.renderPanel();
};

window.PanelManager.prototype.handleModeChange = function (newMode) {
  this.state.themeMode = newMode;
  const currentState = this.storage.get('xGhostedState', {});
  const updatedState = {
    ...currentState,
    panel: {
      ...currentState.panel,
      themeMode: newMode,
    },
  };
  this.storage.set('xGhostedState', updatedState);
  this.log(`Saved themeMode: ${newMode}`);
  this.document.dispatchEvent(
    new CustomEvent('xghosted:theme-mode-changed', {
      detail: { themeMode: newMode }
    })
  );
  this.renderPanel();
};

window.PanelManager.prototype.generateCSVData = function () {
  const headers = ['Link', 'Quality', 'Reason', 'Checked'];
  const rows = this.postsManager
    .getAllPosts()
    .map(([id, { analysis, checked }]) => {
      return [
        `${this.postsManager.linkPrefix}${id}`,
        analysis.quality.name,
        analysis.reason,
        checked ? 'true' : 'false',
      ].join(',');
    });
  return [headers.join(','), ...rows].join('\n');
};

window.PanelManager.prototype.copyLinks = function () {
  const linksText = this.postsManager
    .getProblemPosts()
    .map(([link]) => `${this.postsManager.linkPrefix}${link}`)
    .join('\n');
  return navigator.clipboard
    .writeText(linksText)
    .then(() => {
      this.log('Problem links copied to clipboard');
      alert('Problem links copied to clipboard!');
    })
    .catch((err) => {
      this.log(`Failed to copy problem links: ${err}`);
      alert('Failed to copy problem links.');
    });
};

window.PanelManager.prototype.exportProcessedPostsCSV = function () {
  const csvData = this.generateCSVData();
  const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = this.document.createElement('a');
  a.href = url;
  a.download = 'processed_posts.csv';
  a.click();
  URL.revokeObjectURL(url);
  this.log(`Exported CSV: processed_posts.csv`);
};

window.PanelManager.prototype.importProcessedPostsCSV = function (
  csvText,
  onClose
) {
  this.log('Import CSV button clicked');
  const count = this.postsManager.importPosts(csvText);
  if (count > 0) {
    this.renderPanel();
    this.document.dispatchEvent(
      new CustomEvent('xghosted:csv-import', {
        detail: { importedCount: count },
      })
    );
    alert(`Successfully imported ${count} posts!`);
    onClose();
  }
};

window.PanelManager.prototype.clearPosts = function () {
  if (confirm('Clear all processed posts?')) {
    this.postsManager.clearPosts();
    this.renderPanel();
    this.document.dispatchEvent(new CustomEvent('xghosted:posts-cleared'));
  }
};

// File: src/ui/SplashPanel.js
// --------------------------------
function SplashPanel(doc, logger, version) {
  this.document = doc;
  this.logger = logger;
  this.container = null;
  this.userProfileName = null;
  this.config = {}; // Initialize as empty object to prevent null errors

  this.init = function () {
      this.logger('Initializing SplashPanel...');
      this.container = this.document.createElement('div');
      this.container.id = 'xghosted-splash';
      this.container.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; border: 2px solid #333; border-radius: 12px; padding: 20px; z-index: 10000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);';
      this.document.body.appendChild(this.container);

      this.render({
          pollInterval: 'Unknown',
          scrollInterval: 'Unknown'
      });

      this.document.addEventListener('xghosted:init', (e) => {
          this.config = e.detail?.config || {};
          this.logger('Received xghosted:init with config:', this.config);
          this.render({
              pollInterval: this.config.pollInterval || 'Unknown',
              scrollInterval: this.config.scrollInterval || 'Unknown'
          });
      }, { once: true });

      this.document.addEventListener('xghosted:user-profile-updated', (e) => {
          const { userProfileName } = e.detail || {};
          this.logger('Received xghosted:user-profile-updated with userProfileName:', userProfileName);
          this.userProfileName = userProfileName;
          this.render({
              pollInterval: this.config.pollInterval || 'Unknown',
              scrollInterval: this.config.scrollInterval || 'Unknown'
          });
      });
  };

  this.render = function (config) {
      this.container.innerHTML = `
          <h2 style="margin: 0 0 10px 0; font-size: 24px; color: #333; display: block;">Welcome to xGhosted!</h2>
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Tampermonkey Version: ${version}</p>
          ${this.userProfileName ? `<p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Profile: ${this.userProfileName}</p>` : ''}
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Poll Interval: ${config.pollInterval} ms</p>
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Scroll Interval: ${config.scrollInterval} ms</p>
          <button style="padding: 8px 16px; background: #3A4A5B; color: #fff; border: 2px solid #8292A2; border-radius: 8px; cursor: pointer; font-size: 14px; display: inline-block;">Close</button>
      `;
      const closeButton = this.container.querySelector('button');
      closeButton.addEventListener('click', () => {
          this.logger('SplashPanel closed');
          this.container.remove();
      });
  };

  try {
      this.init();
  } catch (error) {
      this.logger(`SplashPanel failed to initialize: ${error.message}`);
  }
}

export { SplashPanel };

// File: src/ui/SplashPanel.test.js
// --------------------------------
import { describe, it, expect, vi } from 'vitest';
import { SplashPanel } from './SplashPanel.js';
import { JSDOM } from 'jsdom';

describe('SplashPanel', () => {
  let dom, doc, logger;

  beforeEach(() => {
    dom = new JSDOM('<!DOCTYPE html><body></body>');
    doc = dom.window.document;
    logger = vi.fn();
  });

  it('initializes and renders default content', () => {
    const splash = new SplashPanel(doc, logger, '0.6.1');
    
    expect(doc.getElementById('xghosted-splash')).toBeTruthy();
    expect(doc.querySelector('h2').textContent).toBe('Welcome to xGhosted!');
    expect(doc.querySelectorAll('p')[0].textContent).toBe('Tampermonkey Version: 0.6.1');
    expect(doc.querySelectorAll('p')[1].textContent).toBe('Poll Interval: Unknown ms');
    expect(doc.querySelectorAll('p')[2].textContent).toBe('Scroll Interval: Unknown ms');
    expect(logger).toHaveBeenCalledWith('Initializing SplashPanel...');
  });

  it('updates content on xghosted:init event', () => {
    const splash = new SplashPanel(doc, logger, '0.6.1');
    
    doc.dispatchEvent(new dom.window.CustomEvent('xghosted:init', {
      detail: {
        config: {
          pollInterval: 1000,
          scrollInterval: 1500
        }
      }
    }));

    expect(doc.querySelectorAll('p')[1].textContent).toBe('Poll Interval: 1000 ms');
    expect(doc.querySelectorAll('p')[2].textContent).toBe('Scroll Interval: 1500 ms');
    expect(logger).toHaveBeenCalledWith('Received xghosted:init with config:', {
      pollInterval: 1000,
      scrollInterval: 1500
    });
  });

  it('displays userProfileName on xghosted:user-profile-updated event', async () => {
    const splash = new SplashPanel(doc, logger, '0.6.1');
    
    doc.dispatchEvent(new dom.window.CustomEvent('xghosted:user-profile-updated', {
      detail: {
        userProfileName: 'ApostleJohnW'
      }
    }));

    await new Promise(resolve => setTimeout(resolve, 0));

    expect(doc.querySelectorAll('p')[0].textContent).toBe('Tampermonkey Version: 0.6.1');
    expect(doc.querySelectorAll('p')[1].textContent).toBe('Profile: ApostleJohnW');
    expect(doc.querySelectorAll('p')[2].textContent).toBe('Poll Interval: Unknown ms');
    expect(doc.querySelectorAll('p')[3].textContent).toBe('Scroll Interval: Unknown ms');
    expect(logger).toHaveBeenCalledWith('Received xghosted:user-profile-updated with userProfileName:', 'ApostleJohnW');
  });

  it('removes container on close button click', () => {
    const splash = new SplashPanel(doc, logger, '0.6.1');
    
    const closeButton = doc.querySelector('button');
    closeButton.click();
    
    expect(doc.getElementById('xghosted-splash')).toBeNull();
    expect(logger).toHaveBeenCalledWith('SplashPanel closed');
  });
});

// File: src/utils/ProcessedPostsManager.js
// --------------------------------
import { postQuality } from './postQuality.js';

class ProcessedPostsManager {
  constructor({ storage, log, linkPrefix }) {
    this.storage = storage || { get: () => { }, set: () => { } };
    this.log = log || console.log.bind(console);
    this.linkPrefix = linkPrefix || '';
    this.posts = {};
    this.load();
  }

  load() {
    const state = this.storage.get('xGhostedState', {});
    this.posts = {};
    const savedPosts = state.processedPosts || {};
    for (const [id, { analysis, checked }] of Object.entries(savedPosts)) {
      this.posts[id] = {
        analysis: { ...analysis },
        checked
      };
    }
    this.log(`Loaded ${Object.keys(this.posts).length} posts from storage`);
  }

  save() {
    const state = this.storage.get('xGhostedState', {});
    state.processedPosts = {};
    for (const [id, { analysis, checked }] of Object.entries(this.posts)) {
      state.processedPosts[id] = { analysis: { ...analysis }, checked };
    }
    this.storage.set('xGhostedState', state);
    this.log('Saved processed posts to storage');
  }

  getPost(id) {
    return this.posts[id] || null;
  }

  registerPost(id, data) {
    if (!id || !data?.analysis) {
      this.log(`Invalid post data for id: ${id}`);
      return false;
    }
    this.posts[id] = {
      analysis: { ...data.analysis },
      checked: data.checked || false
    };
    this.log(`Registered post: ${id} with quality: ${this.posts[id].analysis.quality.name}`, this.posts[id].analysis);
    this.save();
    return true;
  }

  getAllPosts() {
    return Object.entries(this.posts);
  }

  getProblemPosts() {
    const allPosts = Object.entries(this.posts);
    const problemPosts = allPosts.filter(
      ([_, { analysis }]) =>
        analysis.quality.name === postQuality.PROBLEM.name ||
        analysis.quality.name === postQuality.POTENTIAL_PROBLEM.name
    );
    this.log(
      `getProblemPosts: Found ${problemPosts.length} posts`,
      problemPosts.map(([id, { analysis }]) => ({ id, quality: analysis.quality.name })),
      `All posts:`,
      allPosts.map(([id, { analysis }]) => ({ id, quality: analysis.quality.name }))
    );
    return problemPosts;
  }

  clearPosts() {
    this.posts = {};
    this.save();
    this.log('Cleared all processed posts');
  }

  importPosts(csvText) {
    if (typeof csvText !== 'string' || !csvText.trim()) {
      this.log('Invalid CSV text provided');
      return 0;
    }
    const lines = csvText
      .trim()
      .split('\n')
      .map((line) =>
        line
          .split(',')
          .map((cell) => cell.replace(/^"|"$/g, '').replace(/""/g, '"'))
      );
    if (lines.length < 2) {
      this.log('CSV must have at least one data row');
      return 0;
    }
    const headers = lines[0];
    const expectedHeaders = ['Link', 'Quality', 'Reason', 'Checked'];
    if (!expectedHeaders.every((header, i) => header === headers[i])) {
      this.log('CSV header mismatch');
      return 0;
    }
    const qualityMap = {
      [postQuality.UNDEFINED.name]: postQuality.UNDEFINED,
      [postQuality.PROBLEM.name]: postQuality.PROBLEM,
      [postQuality.POTENTIAL_PROBLEM.name]: postQuality.POTENTIAL_PROBLEM,
      [postQuality.GOOD.name]: postQuality.GOOD
    };
    let importedCount = 0;
    lines.slice(1).forEach((row) => {
      const [link, qualityName, reason, checkedStr] = row;
      const quality = qualityMap[qualityName];
      if (!quality) return;
      const id = link.replace(this.linkPrefix, '');
      this.posts[id] = {
        analysis: { quality, reason, link: id },
        checked: checkedStr === 'true'
      };
      importedCount++;
    });
    this.save();
    this.log(`Imported ${importedCount} posts from CSV`);
    return importedCount;
  }

  exportPosts() {
    const headers = ['Link', 'Quality', 'Reason', 'Checked'];
    const rows = Object.entries(this.posts).map(([id, { analysis, checked }]) => {
      return [
        `${this.linkPrefix}${id}`,
        analysis.quality.name,
        analysis.reason,
        checked ? 'true' : 'false'
      ].join(',');
    });
    return [headers.join(','), ...rows].join('\n');
  }
}

export { ProcessedPostsManager };

// File: src/utils/clipboardUtils.js
// --------------------------------
function copyTextToClipboard(text, log) {
    return navigator.clipboard
      .writeText(text)
      .then(() => log('Text copied to clipboard'))
      .catch((err) => log(`Clipboard copy failed: ${err}`));
  }
  
  function exportToCSV(data, filename, doc, log) {
    const blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = doc.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    log(`Exported CSV: ${filename}`);
  }
  
  export { copyTextToClipboard, exportToCSV };

// File: src/utils/debounce.js
// --------------------------------
function debounce(func, wait) {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        return new Promise((resolve, reject) => {
            timeout = setTimeout(() => {
                try {
                    const result = func(...args);
                    // If func returns a Promise, resolve with its result
                    if (result && typeof result.then === 'function') {
                        result.then(resolve).catch(reject);
                    } else {
                        resolve(result);
                    }
                } catch (error) {
                    reject(error);
                }
            }, wait);
        });
    };
}

export { debounce };

// File: src/utils/debounce.test.js
// --------------------------------
import { debounce } from './debounce';

describe('debounce', () => {
    let func;
    let debouncedFunc;

    beforeEach(() => {
        func = vi.fn();
        debouncedFunc = debounce(func, 1000);
        vi.useFakeTimers();
    });

    afterEach(() => {
        vi.clearAllMocks();
        vi.useRealTimers();
    });

    test('should call the function after the specified wait time', () => {
        debouncedFunc();
        expect(func).not.toHaveBeenCalled();
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledTimes(1);
    });

    test('should not call the function before the wait time', () => {
        debouncedFunc();
        vi.advanceTimersByTime(500);
        expect(func).not.toHaveBeenCalled();
    });

    test('should call the function only once if called multiple times within the wait time', () => {
        debouncedFunc();
        debouncedFunc();
        debouncedFunc();
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledTimes(1);
    });

    test('should call the function again if called after the wait time', () => {
        debouncedFunc();
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledTimes(1);
        debouncedFunc();
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledTimes(2);
    });

    test('should pass arguments to the original function', () => {
        debouncedFunc('arg1', 42);
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledWith('arg1', 42);
    });

    test('should use the last arguments when called multiple times within wait time', () => {
        debouncedFunc('first');
        debouncedFunc('second');
        debouncedFunc('third');
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledWith('third');
    });

    test('should handle immediate call after previous debounce completes', () => {
        debouncedFunc('first');
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledWith('first');
        debouncedFunc('second');
        vi.advanceTimersByTime(1000);
        expect(func).toHaveBeenCalledWith('second');
    });
});

// File: src/utils/describeSampleAnalyses.js
// --------------------------------
import { summarizeRatedPosts } from './summarizeRatedPosts';
import { postQuality } from './postQuality';

function describeSampleAnalyses(document, analyses) {
  const totalPosts = document.querySelectorAll('div[data-testid="cellInnerDiv"]').length;
  const totalArticles = document.querySelectorAll('article:not(article article)').length;
  const totalNestedArticles = document.querySelectorAll('article article').length;
  const postQualitySummary = summarizeRatedPosts(analyses);

  const $padding = 2;
  const totalGood = postQualitySummary[postQuality.GOOD.name];
  const totalPotentialProblems = postQualitySummary[postQuality.POTENTIAL_PROBLEM.name];
  const totalProblems = postQualitySummary[postQuality.PROBLEM.name];
  const totalUndefined = postQualitySummary[postQuality.UNDEFINED.name];

  return [
    `Structure Summary Totals:`,
    `  ${`${totalPosts}`.padStart($padding, ' ')} Posts`,
    `  ${`${totalArticles}`.padStart($padding, ' ')} Articles`,
    `  ${`${totalNestedArticles}`.padStart($padding, ' ')} Nested Articles`,
    ``,
    `Rated Post Quality (${analyses ? analyses.length : 0} Total):`,
    `  ${`${totalGood}`.padStart($padding, ' ')} ${postQuality.GOOD.name}`,
    `  ${`${totalPotentialProblems}`.padStart($padding, ' ')} ${postQuality.POTENTIAL_PROBLEM.name}`,
    `  ${`${totalProblems}`.padStart($padding, ' ')} ${postQuality.PROBLEM.name}`,
    `  ${`${totalUndefined}`.padStart($padding, ' ')} ${postQuality.UNDEFINED.name}`
  ].join('\n');
}

export { describeSampleAnalyses };

// File: src/utils/findReplyingToWithDepth.js
// --------------------------------
function findReplyingToWithDepth(article) {

  function getInnerHTMLWithoutAttributes(element) {
      const clone = element.cloneNode(true);
      clone.querySelectorAll('*').forEach(el => {
          while (el.attributes.length > 0) {
              el.removeAttribute(el.attributes[0].name);
          }
      });
      return clone.innerHTML;
  }

  function findDivs(element, depth) {
      if (element.tagName === 'DIV') {
          if (element.innerHTML.startsWith('Replying to')) {
              result.push({
                  depth,
                  innerHTML: getInnerHTMLWithoutAttributes(element)
                      .replace(/<\/?(div|span)>/gi, '')
              });
          }
      }

      Array.from(element.children).forEach(child => findDivs(child, depth + 1));
  }
  
  const result = [];
  findDivs(article, 0);
  return result;
}

export { findReplyingToWithDepth };

// File: src/utils/findReplyingToWithDepth.test.js
// --------------------------------
import { findReplyingToWithDepth } from './findReplyingToWithDepth';
import { JSDOM } from 'jsdom';

describe('findReplyingToWithDepth', () => {

    const dom = new JSDOM('<!DOCTYPE html><div></div>');
    global.document = dom.window.document;

    function createArticle(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div;
    }

    test('returns array with reply data when present', () => {
        const article = createArticle('<article><div>Replying to @user</div></article>');
        const result = findReplyingToWithDepth(article);
        expect(result).toEqual([{ depth: 2, innerHTML: 'Replying to @user' }]);
    });

    test('returns empty array when no replies found', () => {
        const article = createArticle('<article><div>Hello world</div></article>');
        const result = findReplyingToWithDepth(article);
        expect(result).toEqual([]);
    });

    test('tracks depth correctly', () => {
        const article = createArticle('<article><div><div>Replying to @user</div></div></article>');
        const result = findReplyingToWithDepth(article);
        expect(result).toEqual([{ depth: 3, innerHTML: 'Replying to @user' }]);
    });
});

// File: src/utils/getRelativeLinkToPost.js
// --------------------------------
function getRelativeLinkToPost(element) {
    //const link = element.querySelector('.css-146c3p1.r-1loqt21 time')?.parentElement?.getAttribute('href');
    const link = element.querySelector('a:has(time)')?.getAttribute('href');
    return link || false;
}

export { getRelativeLinkToPost };


// File: src/utils/getRelativeLinkToPost.test.js
// --------------------------------
import { getRelativeLinkToPost } from './getRelativeLinkToPost';

test("We can extract relative link to post", () => {
    loadHTML('samples/Home-Timeline-With-Reply-To-Repost-No-Longer-Available-Isolated.html');
    const post = document.querySelector('div[data-testid="cellInnerDiv"]');
    const result = getRelativeLinkToPost(post);
    expect(result).toBe("/OwenGregorian/status/1896977661144260900");
    document.documentElement.innerHTML = '';
  });

// File: src/utils/identifyPost.js
// --------------------------------
import { postHasProblemCommunity } from './postHasProblemCommunity';
import { postHasProblemSystemNotice } from './postHasProblemSystemNotice';
import { findReplyingToWithDepth } from './findReplyingToWithDepth';
import { getRelativeLinkToPost } from './getRelativeLinkToPost';
import { postQuality } from './postQuality';

function identifyPost(post, checkReplies = true, logger = console.log) {
    const article = post.querySelector('article');
    if (!article) {
        return {
            quality: postQuality.UNDEFINED,
            reason: "No article found",
            link: false,
        };
    }

    // Posts with system notices are problems
    const noticeFound = postHasProblemSystemNotice(article);
    if (noticeFound) {
        return {
            quality: postQuality.PROBLEM,
            reason: `Found notice: ${noticeFound}`,
            link: getRelativeLinkToPost(post),
        };
    }

    // Posts with target communities are problems
    const communityFound = postHasProblemCommunity(article);
    if (communityFound) {
        return {
            quality: postQuality.PROBLEM,
            reason: `Found community: ${communityFound}`,
            link: getRelativeLinkToPost(post),
        };
    }

    if (checkReplies) {
        // Posts with "Replying to" might be potential problems when found on with_replies page
        const replyingToDepths = findReplyingToWithDepth(article);
        // logger(`Checking replies for post, found ${replyingToDepths.length} "Replying to" instances:`, replyingToDepths);
        if (Array.isArray(replyingToDepths) && replyingToDepths.length > 0) {
            // Posts with replying to found at a depth < 10 are potential problems
            const replyingTo = replyingToDepths.find(object => object.depth < 10);
            if (replyingTo) {
                // logger(`POTENTIAL_PROBLEM detected: '${replyingTo.innerHTML}' at depth ${replyingTo.depth}`);
                return {
                    quality: postQuality.POTENTIAL_PROBLEM,
                    reason: `Found: '${replyingTo.innerHTML}' at a depth of ${replyingTo.depth}`,
                    link: getRelativeLinkToPost(post),
                };
            } else {
                // logger('No "Replying to" found at depth < 10');
            }
        } else {
            // logger('No "Replying to" divs found');
        }
    }

    // By process of elimination, this is either good or undefined
    const link = getRelativeLinkToPost(post);
    if (link) {
        return {
            quality: postQuality.GOOD,
            reason: "Looks good",
            link: link,
        };
    }

    return {
        quality: postQuality.UNDEFINED,
        reason: "Nothing to measure",
        link: false,
    };
}

export { identifyPost };

// File: src/utils/identifyPosts.js
// --------------------------------
import { identifyPost } from './identifyPost';

function identifyPosts(document, selector='div[data-testid="cellInnerDiv"]', checkReplies = true) {
    const results = [];
    
    (document.querySelectorAll(selector)).forEach((post) => {
        const analysis = identifyPost(post, checkReplies);

        results.push(analysis);
    });

    return results;
}

export { identifyPosts };

// File: src/utils/identifyPosts.sample.test.js
// --------------------------------
import { postQuality } from './postQuality';
import { identifyPosts } from './identifyPosts';
import { describeSampleAnalyses } from './describeSampleAnalyses';

test('identifyPosts classifies posts', () => {
  // Same sample used in src/xGhosted.test.js
  loadHTML('samples/Home-Timeline-With-Reply-To-Repost-No-Longer-Available.html');
  const { GOOD, PROBLEM, POTENTIAL_PROBLEM, UNDEFINED } = postQuality;
  const analyses = identifyPosts(document);

  expect(describeSampleAnalyses(document, analyses)).toBe([
    "Structure Summary Totals:",
    "  36 Posts",
    "  24 Articles",
    "   1 Nested Articles",
    "",
    "Rated Post Quality (36 Total):",
    "  21 Good",
    "   2 Potential Problem",
    "   1 Problem",
    "  12 Undefined"
  ].join("\n"));

  expect(analyses[0]).toEqual({ quality: GOOD, link: "/DongWookChung2/status/1887852588457988314", reason: "Looks good", });
  expect(analyses[1]).toEqual({ quality: GOOD, link: "/monetization_x/status/1897010659075989835", reason: "Looks good", });
  expect(analyses[2]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897016048639180873", reason: "Looks good", });
  expect(analyses[3]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[4]).toEqual({ quality: GOOD, link: "/Name__Error_404/status/1896938936599228642", reason: "Looks good", });
  expect(analyses[5]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[6]).toEqual({ quality: GOOD, link: "/Name__Error_404/status/1897015679158788554", reason: "Looks good", });
  expect(analyses[7]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897015899099414914", reason: "Looks good", });
  expect(analyses[8]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[9]).toEqual({ quality: GOOD, link: "/Name__Error_404/status/1897015203541524847", reason: "Looks good", });
  expect(analyses[10]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897015449176748449", reason: "Looks good", });
  expect(analyses[11]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[12]).toEqual({ quality: GOOD, link: "/SpaceX/status/1896708396902174849", reason: "Looks good", });
  expect(analyses[13]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897003945203306614", reason: "Looks good", });
  expect(analyses[14]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897013413664145793", reason: "Looks good", });
  expect(analyses[15]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[16]).toEqual({ quality: PROBLEM, link: "/OwenGregorian/status/1896977661144260900", reason: "Found notice: this post is unavailable" });
  expect(analyses[17]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897011110072738182", reason: "Looks good", });
  expect(analyses[18]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[19]).toEqual({ quality: GOOD, link: "/DongWookChung2/status/1897005083709374868", reason: "Looks good", });
  expect(analyses[20]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897010202974806174", reason: "Looks good", });
  expect(analyses[21]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[22]).toEqual({ quality: GOOD, link: "/monetization_x/status/1896999071665324318", reason: "Looks good", });
  expect(analyses[23]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[24]).toEqual({ quality: GOOD, link: "/godswayfoundinc/status/1897003429870129243", reason: "Looks good", });
  expect(analyses[25]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897004848614420667", reason: "Looks good", });
  expect(analyses[26]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[27]).toEqual({ quality: POTENTIAL_PROBLEM, link: "/ApostleJohnW/status/1897004713570394503", reason: "Found: 'Replying to <a>@godswayfoundinc</a> and <a>@monetization_x</a>' at a depth of 6", });
  expect(analyses[28]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[29]).toEqual({ quality: GOOD, link: "/godswayfoundinc/status/1897002671846121539", reason: "Looks good", });
  expect(analyses[30]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897002963107025141", reason: "Looks good", });
  expect(analyses[31]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[32]).toEqual({ quality: GOOD, link: "/WesleyKy/status/1896999314582642895", reason: "Looks good", });
  expect(analyses[33]).toEqual({ quality: GOOD, link: "/ApostleJohnW/status/1897002818214748430", reason: "Looks good", });
  expect(analyses[34]).toEqual({ quality: UNDEFINED, link: false, reason: "No article found", });
  expect(analyses[35]).toEqual({ quality: POTENTIAL_PROBLEM, link: "/ApostleJohnW/status/1897002239753073002", reason: "Found: 'Replying to <a>@monetization_x</a>' at a depth of 6", });

  document.documentElement.innerHTML = '';
});

// File: src/utils/identifyPosts.samples.test.skip.js
// --------------------------------
import { postQuality } from './postQuality';
import { identifyPosts } from './identifyPosts';
import { describeSampleAnalyses } from './describeSampleAnalyses';
import { postHasProblemSystemNotice } from './postHasProblemSystemNotice';
import { expect } from 'vitest';
const { PROBLEM, POTENTIAL_PROBLEM, GOOD, UNDEFINED } = postQuality;

it('should find one problem and one potential problem post', () => {
  loadHTML('samples/ajweltytest-with-replies.html');
  const analyses = identifyPosts(document);

  expect(describeSampleAnalyses(document, analyses)).toBe([
    "Structure Summary Totals:",
    "  16 Posts",
    "   6 Articles",
    "   1 Nested Articles",
    "",
    "Rated Post Quality (16 Total):",
    "   4 Good",
    "   1 Potential Problem",
    "   1 Problem",
    "  10 Undefined"
  ].join("\n"));

  expect(analyses).toEqual([
    { link: "/ajweltytest/status/1901080866002014636", quality: PROBLEM, reason: "Found notice: this post is unavailable" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: "/ApostleJohnW/status/1899820744072110204", quality: GOOD, reason: "Looks good" },
    { link: "/ajweltytest/status/1899820959197995180", quality: GOOD, reason: "Looks good" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: "/ajweltytest/status/1899820920266535120", quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@ApostleJohnW</a>' at a depth of 6" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: "/ApostleJohnW/status/1895367468908192087", quality: GOOD, reason: "Looks good" },
    { link: "/ajweltytest/status/1895407388871798985", quality: GOOD, reason: "Looks good" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" },
    { link: false, quality: UNDEFINED, reason: "No article found" }
  ]);
});

describe('identifyPosts - Good', () => {

  it('should identify 8 good and 3 undefined in this sample size of 11', () => {
    loadHTML('samples/Home-Timeline-With-Replies.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "  11 Posts",
      "   8 Articles",
      "   0 Nested Articles",
      "",
      "Rated Post Quality (11 Total):",
      "   8 Good",
      "   0 Potential Problem",
      "   0 Problem",
      "   3 Undefined"
    ].join("\n"));

    expect(analyses).toEqual([
      { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1895111411140907450" },
      { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1895174358902956217" },
      { quality: UNDEFINED, reason: "No article found", link: false },
      { quality: GOOD, reason: "Looks good", link: "/buymeacoffee/status/1895088351235187111" },
      { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1895172905203589591" },
      { quality: UNDEFINED, reason: "No article found", link: false },
      { quality: GOOD, reason: "Looks good", link: "/monetization_x/status/1894962473914298538" },
      { quality: UNDEFINED, reason: "No article found", link: false },
      { quality: GOOD, reason: "Looks good", link: "/tahreem57/status/1894971735172149613" },
      { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1895169898252509372" },
      { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1895168899793994232" }
    ]);

    document.documentElement.innerHTML = '';
  });

  it('should find 2 good and 4 undefined posts in this sample size of 6', () => {
    loadHTML('samples/Conversation-without-problems.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "   6 Posts",
      "   3 Articles",
      "   0 Nested Articles",
      "",
      "Rated Post Quality (6 Total):",
      "   3 Good",
      "   0 Potential Problem",
      "   0 Problem",
      "   3 Undefined"
    ].join("\n"));

    expect(analyses[0]).toEqual({
      quality: GOOD,
      reason: "Looks good",
      link: "/Eddie_1X/status/1881836273264103665"
    });

    expect(analyses[1]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1881841967291928947" });
    expect(analyses[2]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
    expect(analyses[3]).toEqual({ quality: GOOD, reason: "Looks good", link: "/Eddie_1X/status/1881843269208093033" });
    expect(analyses[4]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
    expect(analyses[5]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });

    document.documentElement.innerHTML = '';
  });

  it('should identify this good post (1)', () => {
    loadHTML('samples/Replying-To-Embedded-Example.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "   1 Posts",
      "   1 Articles",
      "   0 Nested Articles",
      "",
      "Rated Post Quality (1 Total):",
      "   1 Good",
      "   0 Potential Problem",
      "   0 Problem",
      "   0 Undefined"
    ].join("\n"));

    expect(analyses).toEqual([{ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890787999731913068", }]);

    document.documentElement.innerHTML = '';
  });

  it('should identify this good post (2)', () => {
    loadHTML('samples/Replying-To-Healthy-Example.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "   1 Posts",
      "   1 Articles",
      "   0 Nested Articles",
      "",
      "Rated Post Quality (1 Total):",
      "   1 Good",
      "   0 Potential Problem",
      "   0 Problem",
      "   0 Undefined"
    ].join("\n"));

    expect(analyses).toEqual([{ quality: GOOD, reason: "Looks good", link: "/TRHLofficial/status/1890488779200135602", },]);

    document.documentElement.innerHTML = '';
  });

  it('should identify this good post (3)', () => {
    loadHTML('samples/This-Quote-Repost-Into-Community-Should-Be-Fine.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "   1 Posts",
      "   1 Articles",
      "   0 Nested Articles",
      "",
      "Rated Post Quality (1 Total):",
      "   1 Good",
      "   0 Potential Problem",
      "   0 Problem",
      "   0 Undefined"
    ].join("\n"));

    expect(analyses).toEqual([{ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1898022285140758652", },]);

    document.documentElement.innerHTML = '';
  });

});

describe('identifyPosts - Problems', () => {

  describe('problem posts identified with postHasProblemCommunity', () => {

    it('should find a problem community referenced in this sample size of 4', () => {
      loadHTML('samples/CommunityPost-TargetCommunity.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   4 Posts",
        "   2 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (4 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   2 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: PROBLEM, reason: "Found community: 1889908654133911912", link: "/ApostleJohnW/status/1898022285140758652" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/Waqar_sahito01/status/1898023692958843033" },
        { quality: UNDEFINED, reason: "No article found", link: false }
      ]);

      document.documentElement.innerHTML = '';
    });

    // Happy path
    it('should find no problems with the community post in this sample size of 4', () => {
      loadHTML('samples/CommunityPost.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   4 Posts",
        "   4 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (4 Total):",
        "   4 Good",
        "   0 Potential Problem",
        "   0 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1888719160592453713" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1888717684822438329" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1888713602850320746" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1888712977848656024" }
      ]);

      document.documentElement.innerHTML = '';
    });

  });

  describe('problem posts identified with postHasProblemSystemNotice', () => {

    it('should identify a deleted post problem in this sample size of 4', () => {
      loadHTML('samples/Conversation-with-Deleted-Post.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   4 Posts",
        "   4 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (4 Total):",
        "   3 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/Breaking911/status/1884691881587523595" },
        { quality: PROBLEM, reason: "Found notice: this post was deleted by the post author", link: false },
        { quality: GOOD, reason: "Looks good", link: "/WarPumpkin22/status/1884794131643314464" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1884794615716307143" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify an unavailable account problem in this sample size of 3', () => {
      loadHTML('samples/Conversation-with-account-no-longer-available.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   3 Posts",
        "   2 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (3 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   1 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: PROBLEM, reason: "Found notice: this post is from an account that no longer exists", link: false },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1880635863631344062" },
        { quality: UNDEFINED, reason: "No article found", link: false }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify a copyright violation in this sample size of 20', () => {
      loadHTML('samples/Conversation-with-copyright-violating-quote-repost.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "  20 Posts",
        "  11 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (20 Total):",
        "   9 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "  10 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({ quality: PROBLEM, reason: "Found notice: this media has been disabled in response to a report by the copyright owner", link: "/awkwardgoogle/status/1894810490347409752" });
      expect(analyses[1]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[2]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1894812853124706554" });
      expect(analyses[3]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[4]).toEqual({ quality: GOOD, reason: "Looks good", link: "/MyBasicFinance/status/1894819472562651293" });
      expect(analyses[5]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[6]).toEqual({ quality: GOOD, reason: "Looks good", link: "/MattZeeMiller/status/1894849813050740802" });
      expect(analyses[7]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[8]).toEqual({ quality: GOOD, reason: "Looks good", link: "/DaytonDan55/status/1894837596963951054" });
      expect(analyses[9]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[10]).toEqual({ quality: GOOD, reason: "Looks good", link: "/YHfLNQEzT942049/status/1894948247187403259" });
      expect(analyses[11]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[12]).toEqual({ quality: GOOD, reason: "Looks good", link: "/daz1985/status/1894834410198835673" });
      expect(analyses[13]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[14]).toEqual({ quality: GOOD, reason: "Looks good", link: "/Harry_Bdict/status/1894810993449955580" });
      expect(analyses[15]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[16]).toEqual({ quality: GOOD, reason: "Looks good", link: "/Harry_Bdict/status/1894810900009201975" });
      expect(analyses[17]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[18]).toEqual({ quality: GOOD, reason: "Looks good", link: "/smokedandsalted/status/1894811105706271142" });
      expect(analyses[19]).toEqual({ quality: UNDEFINED, reason: "Nothing to measure", link: false });

      document.documentElement.innerHTML = '';
    });

    it('should identify no longer available without a subscription in this sample size of 3', () => {
      loadHTML('samples/Conversation-with-expired-subscription.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   3 Posts",
        "   2 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (3 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   1 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({
        quality: PROBLEM,
        reason: "Found notice: you're unable to view this post",
        link: false
      });

      expect(analyses[1]).toEqual({
        quality: GOOD,
        reason: "Looks good",
        link: "/ApostleJohnW/status/1882615672984969338"
      });

      expect(analyses[2]).toEqual({
        quality: UNDEFINED,
        reason: "No article found",
        link: false
      });

      document.documentElement.innerHTML = '';
    });

    it('should identify two unable to view post problems in this sample size of 6', () => {
      loadHTML('samples/Conversation-with-limited-visibility.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   6 Posts",
        "   4 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (6 Total):",
        "   2 Good",
        "   0 Potential Problem",
        "   2 Problem",
        "   2 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({ quality: PROBLEM, reason: "Found notice: you're unable to view this post", link: false });
      expect(analyses[1]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1883292681188917450" });
      expect(analyses[2]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });
      expect(analyses[3]).toEqual({ quality: PROBLEM, reason: "Found notice: you're unable to view this post", link: false });
      expect(analyses[4]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1883293430052430332" });
      expect(analyses[5]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });

      document.documentElement.innerHTML = '';
    });


    it('should identify the unavailable post in this sample size of 4', () => {
      loadHTML('samples/Conversation-with-now-unavailable-post-included.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   4 Posts",
        "   4 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (4 Total):",
        "   3 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({ quality: GOOD, reason: "Looks good", link: "/iam_smx/status/1883977770709258287" });
      expect(analyses[1]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1883978356900913165" });
      expect(analyses[2]).toEqual({ quality: PROBLEM, reason: "Found notice: this post is unavailable", link: false });
      expect(analyses[3]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1884150859036254640" });

      document.documentElement.innerHTML = '';
    });

    it('should identify the unavailable post in this sample size of 3 including 1 nested article', () => {
      loadHTML('samples/Conversation-with-quoted-post-unavailable.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   3 Posts",
        "   2 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (3 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   1 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({ quality: PROBLEM, reason: "Found notice: this post is unavailable", link: "/RepNancyMace/status/1884565403483218235" });
      expect(analyses[1]).toEqual({ quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1884566696322592842" });
      expect(analyses[2]).toEqual({ quality: UNDEFINED, reason: "No article found", link: false });

      document.documentElement.innerHTML = '';
    });

    // Problem found in nested article
    it("should identify the unavailable post problem in this nested article", () => {
      loadHTML('samples/Home-Timeline-With-Reply-To-Repost-No-Longer-Available-Isolated.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   1 Posts",
        "   1 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (1 Total):",
        "   0 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   0 Undefined"
      ].join("\n"));

      const article = document.querySelector('div[data-testid="cellInnerDiv"]');
      const result = postHasProblemSystemNotice(article);
      expect(result).toBe("this post is unavailable");

      document.documentElement.innerHTML = '';
    });

    // Problem found in nested article
    it("should identify the unavailable post problem in this nested article", () => {
      loadHTML('samples/Home-Timeline-With-Reply-To-Repost-No-Longer-Available-Isolated.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   1 Posts",
        "   1 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (1 Total):",
        "   0 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([{ quality: PROBLEM, reason: "Found notice: this post is unavailable", link: "/OwenGregorian/status/1896977661144260900" }]);

      document.documentElement.innerHTML = '';
    });

    // Problem found in tested article
    it('should find the unavailable post problem in this nested article', () => {
      loadHTML('samples/Post-No-Longer-Available.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
