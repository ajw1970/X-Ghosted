            })
          ),
          window.preact.h('textarea', {
            className: 'modal-textarea',
            value: csvText,
            onInput: (e) => setCsvText(e.target.value),
            placeholder:
              'Paste CSV content (e.g. Link Quality Reason Checked) or select a file above',
            'aria-label': 'CSV content input',
          }),
          window.preact.h(
            'div',
            { className: 'modal-button-container' },
            window.preact.h(
              'button',
              {
                className: 'modal-button',
                onClick: () => onSubmit(csvText),
                'aria-label': 'Submit CSV content',
              },
              window.preact.h('i', {
                className: 'fas fa-check',
                style: { marginRight: '6px' },
              }),
              'Submit'
            ),
            window.preact.h(
              'button',
              {
                className: 'modal-button',
                onClick: () => {
                  setCsvText('');
                  onClose();
                },
                'aria-label': 'Close modal and clear input',
              },
              window.preact.h('i', {
                className: 'fas fa-times',
                style: { marginRight: '6px' },
              }),
              'Close'
            )
          )
        )
      );
    }
    window.Modal = Modal;
    window.PanelManager = function (
      doc,
      xGhostedInstance,
      themeMode = 'light',
      postsManager,
      storage
    ) {
      this.document = doc;
      this.xGhosted = xGhostedInstance;
      this.log = xGhostedInstance.log;
      this.postsManager = postsManager;
      this.storage = storage || { get: () => {}, set: () => {} };
      const validThemes = ['light', 'dim', 'dark'];
      this.state = {
        panelPosition: { right: '10px', top: '60px' },
        instance: xGhostedInstance,
        isPanelVisible: true,
        isRateLimited: false,
        isManualCheckEnabled: false,
        isPollingEnabled: true,
        isAutoScrollingEnabled: false,
        themeMode: validThemes.includes(themeMode) ? themeMode : 'light',
      };
      this.log(
        `PanelManager initialized with themeMode: ${this.state.themeMode}`
      );
      this.uiElements = {
        config: {
          PANEL: {
            WIDTH: '400px',
            MAX_HEIGHT: 'calc(100vh - 70px)',
            TOP: '60px',
            RIGHT: '10px',
            Z_INDEX: '9999',
            FONT: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
          },
          THEMES: {
            light: {
              bg: '#FFFFFF',
              text: '#292F33',
              buttonText: '#000000',
              border: '#B0BEC5',
              button: '#3A4A5B',
              hover: '#90A4AE',
              scroll: '#CCD6DD',
              placeholder: '#666666',
              problem: 'red',
              potentialProblem: 'yellow',
              eyeballColor: 'rgb(29, 155, 240)',
            },
            dim: {
              bg: '#15202B',
              text: '#D9D9D9',
              buttonText: '#FFFFFF',
              border: '#8292A2',
              button: '#3A4A5B',
              hover: '#8292A2',
              scroll: '#4A5C6D',
              placeholder: '#A0A0A0',
              problem: 'red',
              potentialProblem: 'yellow',
              eyeballColor: 'rgb(29, 155, 240)',
            },
            dark: {
              bg: '#000000',
              text: '#D9D9D9',
              buttonText: '#FFFFFF',
              border: '#888888',
              button: '#3A4A5B',
              hover: '#888888',
              scroll: '#666666',
              placeholder: '#A0A0A0',
              problem: 'red',
              potentialProblem: 'yellow',
              eyeballColor: 'rgb(29, 155, 240)',
            },
          },
        },
        panel: null,
        panelContainer: null,
      };
      this.styleElement = null;
      this.dragState = {
        isDragging: false,
        startX: 0,
        startY: 0,
        initialRight: 0,
        initialTop: 0,
      };
      this.init();
    };
    window.PanelManager.prototype.init = function () {
      this.loadState();
      this.uiElements.panelContainer = this.document.createElement('div');
      this.uiElements.panelContainer.id = 'xghosted-panel-container';
      this.uiElements.panel = this.document.createElement('div');
      this.uiElements.panel.id = 'xghosted-panel';
      this.uiElements.panelContainer.appendChild(this.uiElements.panel);
      this.document.body.appendChild(this.uiElements.panelContainer);
      if (window.xGhostedStyles) {
        if (window.xGhostedStyles.modal) {
          const modalStyleSheet = this.document.createElement('style');
          modalStyleSheet.textContent = window.xGhostedStyles.modal;
          this.document.head.appendChild(modalStyleSheet);
        }
        if (window.xGhostedStyles.panel) {
          const panelStyleSheet = this.document.createElement('style');
          panelStyleSheet.textContent = window.xGhostedStyles.panel;
          this.document.head.appendChild(panelStyleSheet);
        }
      }
      this.state.isRateLimited = this.xGhosted.state.isRateLimited;
      this.state.isPollingEnabled = this.xGhosted.state.isPollingEnabled;
      this.state.isAutoScrollingEnabled =
        this.xGhosted.state.isAutoScrollingEnabled;
      this.uiElements.panelContainer.style.right =
        this.state.panelPosition.right;
      this.uiElements.panelContainer.style.top = this.state.panelPosition.top;
      this.uiElements.panelContainer.style.left = 'auto';
      this.styleElement = this.document.createElement('style');
      this.document.head.appendChild(this.styleElement);
      this.applyPanelStyles();
      const handleStateUpdated = (e) => {
        this.state.isRateLimited = e.detail.isRateLimited;
        this.renderPanel();
      };
      const handlePollingStateUpdated = (e) => {
        this.state.isPollingEnabled = e.detail.isPollingEnabled;
        this.renderPanel();
        this.applyPanelStyles();
      };
      const handleAutoScrollingToggled = (e) => {
        this.state.isAutoScrollingEnabled = e.detail.isAutoScrollingEnabled;
        this.renderPanel();
      };
      this.document.addEventListener(
        'xghosted:state-updated',
        handleStateUpdated
      );
      this.document.addEventListener(
        'xghosted:polling-state-updated',
        handlePollingStateUpdated
      );
      this.document.addEventListener(
        'xghosted:auto-scrolling-toggled',
        handleAutoScrollingToggled
      );
      this.cleanup = () => {
        this.document.removeEventListener(
          'xghosted:state-updated',
          handleStateUpdated
        );
        this.document.removeEventListener(
          'xghosted:polling-state-updated',
          handlePollingStateUpdated
        );
        this.document.removeEventListener(
          'xghosted:auto-scrolling-toggled',
          handleAutoScrollingToggled
        );
      };
      if (window.preact && window.preact.h) {
        this.renderPanel();
      } else {
        this.log('Preact h not available, skipping panel render');
      }
    };
    window.PanelManager.prototype.saveState = function () {
      const currentState = this.storage.get('xGhostedState', {});
      const updatedState = {
        ...currentState,
        panel: {
          isPanelVisible: this.state.isPanelVisible,
          panelPosition: { ...this.state.panelPosition },
          themeMode: this.state.themeMode,
        },
      };
      this.storage.set('xGhostedState', updatedState);
      this.log('Saved panel state:', updatedState);
    };
    window.PanelManager.prototype.loadState = function () {
      const savedState = this.storage.get('xGhostedState', {});
      const panelState = savedState.panel || {};
      this.state.isPanelVisible = panelState.isPanelVisible ?? true;
      this.state.themeMode = ['light', 'dim', 'dark'].includes(
        panelState.themeMode
      )
        ? panelState.themeMode
        : this.state.themeMode;
      if (
        panelState.panelPosition &&
        panelState.panelPosition.right &&
        panelState.panelPosition.top
      ) {
        const panelWidth = 350;
        const panelHeight = 48;
        const windowWidth = this.document.defaultView.innerWidth;
        const windowHeight = this.document.defaultView.innerHeight;
        let right = '10px';
        if (
          typeof panelState.panelPosition.right === 'string' &&
          panelState.panelPosition.right.endsWith('px')
        ) {
          const parsedRight = parseFloat(panelState.panelPosition.right);
          if (!isNaN(parsedRight)) {
            right = `${Math.max(0, Math.min(parsedRight, windowWidth - panelWidth))}px`;
          } else {
            this.log(
              `Invalid stored right position: ${panelState.panelPosition.right}, defaulting to 10px`
            );
          }
        } else {
          this.log(
            `Invalid or missing stored right position: ${panelState.panelPosition.right}, defaulting to 10px`
          );
        }
        let top = '60px';
        if (
          typeof panelState.panelPosition.top === 'string' &&
          panelState.panelPosition.top.endsWith('px')
        ) {
          const parsedTop = parseFloat(panelState.panelPosition.top);
          if (!isNaN(parsedTop)) {
            top = `${Math.max(0, Math.min(parsedTop, windowHeight - panelHeight))}px`;
          } else {
            this.log(
              `Invalid stored top position: ${panelState.panelPosition.top}, defaulting to 60px`
            );
          }
        } else {
          this.log(
            `Invalid or missing stored top position: ${panelState.panelPosition.top}, defaulting to 60px`
          );
        }
        this.state.panelPosition.right = right;
        this.state.panelPosition.top = top;
      }
      this.log(
        `Loaded panel state: isPanelVisible=${this.state.isPanelVisible}, themeMode=${this.state.themeMode}, right=${this.state.panelPosition.right}, top=${this.state.panelPosition.top}`
      );
    };
    window.PanelManager.prototype.applyPanelStyles = function () {
      const position = this.state.panelPosition || {
        right: '10px',
        top: '60px',
      };
      this.styleElement.textContent = `
    button:active { transform: scale(0.95); }
    #xghosted-panel-container {
      position: fixed;
      right: ${position.right};
      top: ${position.top};
      z-index: ${this.uiElements.config.PANEL.Z_INDEX};
      cursor: move;
      border-radius: 12px;
    }
  `;
    };
    window.PanelManager.prototype.toggleVisibility = function (newVisibility) {
      this.state.isPanelVisible =
        typeof newVisibility === 'boolean'
          ? newVisibility
          : !this.state.isPanelVisible;
      this.saveState();
      this.renderPanel();
      this.document.dispatchEvent(
        new CustomEvent('xghosted:toggle-panel-visibility', {
          detail: { isPanelVisible: this.state.isPanelVisible },
        })
      );
    };
    window.PanelManager.prototype.setPanelPosition = function (position) {
      this.state.panelPosition = { ...position };
      this.saveState();
      this.log(
        `Updated panel position: right=${position.right}, top=${position.top}`
      );
    };
    window.PanelManager.prototype.renderPanel = function () {
      if (!this.uiElements.panel) {
        this.log('renderPanel: panel element not initialized, skipping render');
        return;
      }
      this.log(
        `renderPanel: themeMode=${this.state.themeMode}, config.THEMES=`,
        this.uiElements.config.THEMES
      );
      window.preact.render(
        window.preact.h(window.Panel, {
          state: this.state,
          config: this.uiElements.config,
          xGhosted: this.xGhosted,
          currentMode: this.state.themeMode,
          toggleThemeMode: (newMode) => this.handleModeChange(newMode),
          onStartPolling: () => this.xGhosted.handleStartPolling(),
          onStopPolling: () => this.xGhosted.handleStopPolling(),
          onEyeballClick: (href) => {
            const post = this.document.querySelector(
              `[data-xghosted-id="${href}"]`
            );
            this.xGhosted.userRequestedPostCheck(href, post);
          },
          onCopyLinks: () => this.copyLinks(),
          setPanelPosition: (position) => this.setPanelPosition(position),
        }),
        this.uiElements.panel
      );
    };
    window.PanelManager.prototype.updateTheme = function (newMode) {
      this.state.themeMode = newMode;
      this.renderPanel();
    };
    window.PanelManager.prototype.handleModeChange = function (newMode) {
      this.state.themeMode = newMode;
      const currentState = this.storage.get('xGhostedState', {});
      const updatedState = {
        ...currentState,
        panel: {
          ...currentState.panel,
          themeMode: newMode,
        },
      };
      this.storage.set('xGhostedState', updatedState);
      this.log(`Saved themeMode: ${newMode}`);
      this.document.dispatchEvent(
        new CustomEvent('xghosted:theme-mode-changed', {
          detail: { themeMode: newMode },
        })
      );
      this.renderPanel();
    };
    window.PanelManager.prototype.generateCSVData = function () {
      const headers = ['Link', 'Quality', 'Reason', 'Checked'];
      const rows = this.postsManager
        .getAllPosts()
        .map(([id, { analysis, checked }]) => {
          return [
            `${this.postsManager.linkPrefix}${id}`,
            analysis.quality.name,
            analysis.reason,
            checked ? 'true' : 'false',
          ].join(',');
        });
      return [headers.join(','), ...rows].join('\n');
    };
    window.PanelManager.prototype.copyLinks = function () {
      const linksText = this.postsManager
        .getProblemPosts()
        .map(([link]) => `${this.postsManager.linkPrefix}${link}`)
        .join('\n');
      return navigator.clipboard
        .writeText(linksText)
        .then(() => {
          this.log('Problem links copied to clipboard');
          alert('Problem links copied to clipboard!');
        })
        .catch((err) => {
          this.log(`Failed to copy problem links: ${err}`);
          alert('Failed to copy problem links.');
        });
    };
    window.PanelManager.prototype.exportProcessedPostsCSV = function () {
      const csvData = this.generateCSVData();
      const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = this.document.createElement('a');
      a.href = url;
      a.download = 'processed_posts.csv';
      a.click();
      URL.revokeObjectURL(url);
      this.log(`Exported CSV: processed_posts.csv`);
    };
    window.PanelManager.prototype.importProcessedPostsCSV = function (
      csvText,
      onClose
    ) {
      this.log('Import CSV button clicked');
      const count = this.postsManager.importPosts(csvText);
      if (count > 0) {
        this.renderPanel();
        this.document.dispatchEvent(
          new CustomEvent('xghosted:csv-import', {
            detail: { importedCount: count },
          })
        );
        alert(`Successfully imported ${count} posts!`);
        onClose();
      }
    };
    window.PanelManager.prototype.clearPosts = function () {
      if (confirm('Clear all processed posts?')) {
        this.postsManager.clearPosts();
        this.renderPanel();
        this.document.dispatchEvent(new CustomEvent('xghosted:posts-cleared'));
      }
    };
    return PanelManager;
  })();
  window.ProcessedPostsManager = (function () {
    // src/utils/postQuality.js
    var postQuality = Object.freeze({
      UNDEFINED: Object.freeze({ name: 'Undefined', value: 0 }),
      PROBLEM: Object.freeze({ name: 'Problem', value: 1 }),
      POTENTIAL_PROBLEM: Object.freeze({ name: 'Potential Problem', value: 2 }),
      GOOD: Object.freeze({ name: 'Good', value: 3 }),
    });

    // src/utils/ProcessedPostsManager.js
    var ProcessedPostsManager = class {
      constructor({ storage, log, linkPrefix }) {
        this.storage = storage || { get: () => {}, set: () => {} };
        this.log = log || console.log.bind(console);
        this.linkPrefix = linkPrefix || '';
        this.posts = {};
        this.load();
      }
      load() {
        const state = this.storage.get('xGhostedState', {});
        this.posts = {};
        const savedPosts = state.processedPosts || {};
        for (const [id, { analysis, checked }] of Object.entries(savedPosts)) {
          this.posts[id] = {
            analysis: { ...analysis },
            checked,
          };
        }
        this.log(`Loaded ${Object.keys(this.posts).length} posts from storage`);
      }
      save() {
        const state = this.storage.get('xGhostedState', {});
        state.processedPosts = {};
        for (const [id, { analysis, checked }] of Object.entries(this.posts)) {
          state.processedPosts[id] = { analysis: { ...analysis }, checked };
        }
        this.storage.set('xGhostedState', state);
        this.log('Saved processed posts to storage');
      }
      getPost(id) {
        return this.posts[id] || null;
      }
      registerPost(id, data) {
        if (!id || !data?.analysis) {
          this.log(`Invalid post data for id: ${id}`);
          return false;
        }
        this.posts[id] = {
          analysis: { ...data.analysis },
          checked: data.checked || false,
        };
        this.log(
          `Registered post: ${id} with quality: ${this.posts[id].analysis.quality.name}`,
          this.posts[id].analysis
        );
        this.save();
        return true;
      }
      getAllPosts() {
        return Object.entries(this.posts);
      }
      getProblemPosts() {
        const allPosts = Object.entries(this.posts);
        const problemPosts = allPosts.filter(
          ([_, { analysis }]) =>
            analysis.quality.name === postQuality.PROBLEM.name ||
            analysis.quality.name === postQuality.POTENTIAL_PROBLEM.name
        );
        this.log(
          `getProblemPosts: Found ${problemPosts.length} posts`,
          problemPosts.map(([id, { analysis }]) => ({
            id,
            quality: analysis.quality.name,
          })),
          `All posts:`,
          allPosts.map(([id, { analysis }]) => ({
            id,
            quality: analysis.quality.name,
          }))
        );
        return problemPosts;
      }
      clearPosts() {
        this.posts = {};
        this.save();
        this.log('Cleared all processed posts');
      }
      importPosts(csvText) {
        if (typeof csvText !== 'string' || !csvText.trim()) {
          this.log('Invalid CSV text provided');
          return 0;
        }
        const lines = csvText
          .trim()
          .split('\n')
          .map((line) =>
            line
              .split(',')
              .map((cell) => cell.replace(/^"|"$/g, '').replace(/""/g, '"'))
          );
        if (lines.length < 2) {
          this.log('CSV must have at least one data row');
          return 0;
        }
        const headers = lines[0];
        const expectedHeaders = ['Link', 'Quality', 'Reason', 'Checked'];
        if (!expectedHeaders.every((header, i) => header === headers[i])) {
          this.log('CSV header mismatch');
          return 0;
        }
        const qualityMap = {
          [postQuality.UNDEFINED.name]: postQuality.UNDEFINED,
          [postQuality.PROBLEM.name]: postQuality.PROBLEM,
          [postQuality.POTENTIAL_PROBLEM.name]: postQuality.POTENTIAL_PROBLEM,
          [postQuality.GOOD.name]: postQuality.GOOD,
        };
        let importedCount = 0;
        lines.slice(1).forEach((row) => {
          const [link, qualityName, reason, checkedStr] = row;
          const quality = qualityMap[qualityName];
          if (!quality) return;
          const id = link.replace(this.linkPrefix, '');
          this.posts[id] = {
            analysis: { quality, reason, link: id },
            checked: checkedStr === 'true',
          };
          importedCount++;
        });
        this.save();
        this.log(`Imported ${importedCount} posts from CSV`);
        return importedCount;
      }
      exportPosts() {
        const headers = ['Link', 'Quality', 'Reason', 'Checked'];
        const rows = Object.entries(this.posts).map(
          ([id, { analysis, checked }]) => {
            return [
              `${this.linkPrefix}${id}`,
              analysis.quality.name,
              analysis.reason,
              checked ? 'true' : 'false',
            ].join(',');
          }
        );
        return [headers.join(','), ...rows].join('\n');
      }
    };
    return ProcessedPostsManager;
  })();

  // --- Inject Styles ---

  window.xGhostedStyles = window.xGhostedStyles || {};
  window.xGhostedStyles.modal = `.modal * {
  box-sizing: border-box;
}

.modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 450px;
  max-height: calc(100vh - 100px);
  background: var(--modal-bg);
  color: var(--modal-text);
  border: 2px solid var(--modal-border);
  border-radius: 12px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
  padding: 12px;
  z-index: 10000;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  overflow-x: hidden;
}

.modal-file-input-container {
  width: 100%;
  max-width: 426px;
}

.modal-file-input {
  width: 100%;
  max-width: 100%;
  padding: 8px 12px;
  margin-bottom: 12px;
  background: var(--modal-button-bg);
  color: var(--modal-button-text);
  border: 2px solid var(--modal-border);
  border-radius: 8px;
  font-size: 14px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
}

.modal-textarea {
  width: 100%;
  max-width: 426px;
  height: 150px;
  padding: 8px 12px;
  margin-bottom: 12px;
  background: var(--modal-button-bg);
  color: var(--modal-button-text);
  border: 2px solid var(--modal-border);
  border-radius: 8px;
  font-size: 14px;
  resize: none;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
}

.modal-textarea::placeholder {
  color: var(--placeholder);
  opacity: 1;
}

.modal-button-container {
  display: flex;
  justify-content: flex-end;
}

.modal-button-container > button:not(:last-child) {
  margin-right: 10px;
}

.modal-button {
  display: flex;
  align-items: center;
  padding: 8px 16px;
  background: var(--modal-button-bg);
  color: var(--modal-button-text);
  border: 2px solid var(--modal-border);
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
  transition: background 0.2s ease;
}

.modal-button:hover {
  background: var(--modal-hover-bg);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.3);
}

.modal-button:active {
  transform: scale(0.95);
}`;
  window.xGhostedStyles.panel = `.toolbar {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 8px;
}

.toolbar > div {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
  margin-left: 12px;
}

.toolbar > div > button:not(:last-child) {
  margin-right: 12px;
}

.tools-section {
  /* No opacity to prevent affecting children */
}

.tools-section > div > div:first-child {
  padding-bottom: 12px;
  border-bottom: 2px solid var(--border-color);
}

.manual-check-separator {
  border-bottom: 2px solid var(--border-color);
  margin: 8px 0;
}

.manual-check-section {
  display: flex;
  flex-direction: column;
  margin-bottom: 0px;
}

.content-wrapper {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  padding-right: 4px;
  padding-left: 8px;
  padding-top: 0;
}

.panel-button {
  background: linear-gradient(to bottom, var(--button-bg), color-mix(in srgb, var(--button-bg) 70%, #000000));
  color: var(--button-text);
  border: 2px solid var(--border-color);
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: background 0.2s ease, transform 0.1s ease;
  display: flex;
  align-items: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
  max-width: 160px;
  text-align: center;
}

.panel-button:hover {
  background: var(--hover-bg);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.3);
}

.panel-button:active {
  transform: scale(0.95);
}

.polling-stopped {
  border: 2px solid #FFA500;
}

.custom-dropdown {
  position: relative;
  width: 100%;
}

.dropdown-button {
  width: 100%;
  justify-content: space-between;
  font-size: 14px;
  padding: 8px 12px;
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: var(--button-bg, #3A4A5B);
  color: var(--button-text);
  border: 2px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.2);
  z-index: 1000;
  margin-top: 4px;
}

.dropdown-item {
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600; /* Bolder text for better readability */
  background-color: var(--button-bg, #3A4A5B);
  color: var(--button-text);
}

.dropdown-item:hover {
  background-color: var(--hover-bg);
  color: var(--button-text);
}

.status-label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-color);
}

.link-row {
  display: grid;
  grid-template-columns: 20px 1fr;
  align-items: center;
  column-gap: 8px; /* Adds a consistent gap between columns */
}

.status-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  justify-self: center;
}

.status-eyeball {
  font-size: 16px;
  color: rgb(29, 155, 240);
  cursor: pointer;
  line-height: 20px;
  justify-self: center; /* Centers the eyeball in the column */
}

.status-problem {
  background-color: red;
}

.problem-links-wrapper {
  padding: 0 8px;
}

.problem-links-wrapper::-webkit-scrollbar {
  width: 6px;
}

.problem-links-wrapper::-webkit-scrollbar-thumb {
  background: var(--scroll-color);
  border-radius: 3px;
}

.problem-links-wrapper::-webkit-scrollbar-track {
  background: var(--bg-color);
}

.link-item {
  padding: 2px 0;
  overflow-wrap: break-word;
  word-break: break-all;
}

.link-item a {
  color: var(--text-color);
  text-decoration: none;
}

.link-item a:hover {
  text-decoration: underline;
  color: var(--hover-bg);
}

.problem-posts-header {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-color);
  padding-bottom: 4px;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 8px;
}

.panel-button i {
  font-size: 16px;
  line-height: 1;
}`;

  // --- Initialization with Resource Limits and Rate Limiting ---
  const RATE_LIMIT_PAUSE = 20 * 1000; // 20 seconds in milliseconds
  const postsManager = new window.ProcessedPostsManager({
    storage: {
      get: GM_getValue,
      set: GM_setValue,
    },
    log,
    linkPrefix: 'https://x.com',
  });
  const config = {
    timing: {
      debounceDelay: 500,
      throttleDelay: 1000,
      tabCheckThrottle: 5000,
      exportThrottle: 5000,
      rateLimitPause: RATE_LIMIT_PAUSE,
      pollInterval: 1000,
    },
    showSplash: true,
    log, // Pass logger
    postsManager,
  };
  const xGhosted = new window.XGhosted(document, config);
  xGhosted.state.isManualCheckEnabled = true;

  // Initialize SplashPanel with version only if showSplash is true
  let splashPanel = null;
  if (config.showSplash) {
    splashPanel = new window.SplashPanel(document, log, '0.6.1');
  }

  // Wait for theme detection to initialize PanelManager
  document.addEventListener(
    'xghosted:theme-detected',
    ({ detail: { themeMode } }) => {
      try {
        const panelManager = new window.PanelManager(
          document,
          xGhosted,
          themeMode || 'light',
          postsManager,
          { get: GM_getValue, set: GM_setValue }
        );
        log('GUI Panel initialized successfully');

        // Wire UI events to handlers
        document.addEventListener(
          'xghosted:toggle-panel-visibility',
          ({ detail: { isPanelVisible } }) => {
            panelManager.toggleVisibility(isPanelVisible);
          }
        );
        document.addEventListener('xghosted:copy-links', () => {
          panelManager.copyLinks();
        });
        document.addEventListener('xghosted:export-csv', () => {
          panelManager.exportProcessedPostsCSV();
        });
        document.addEventListener('xghosted:clear-posts', () => {
          panelManager.clearPosts();
        });
        document.addEventListener(
          'xghosted:csv-import',
          ({ detail: { csvText } }) => {
            panelManager.importProcessedPostsCSV(csvText, () => {});
          }
        );
      } catch (error) {
        log(
          `Failed to initialize GUI Panel: ${error.message}. Continuing without panel.`
        );
      }
    },
    { once: true }
  );

  xGhosted.init();
})();


