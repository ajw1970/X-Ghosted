src/xGhosted.test.js

// File: src/dom/detectTheme.js
// --------------------------------
function detectTheme(doc) {
    // First, check for data-theme attribute
    const dataTheme = doc.body.getAttribute('data-theme');
    // console.log(`Detected data-theme: ${dataTheme}`);
    if (dataTheme) {
        if (dataTheme.includes('lights-out') || dataTheme.includes('dark')) {
            return 'dark';
        } else if (dataTheme.includes('dim')) {
            return 'dim';
        } else if (dataTheme.includes('light') || dataTheme.includes('default')) {
            return 'light';
        }
    }

    // Fallback: Check body class
    const bodyClasses = doc.body.classList;
    // console.log(`Body classes: ${Array.from(bodyClasses).join(', ')}`);
    if (
        bodyClasses.contains('dark') ||
        bodyClasses.contains('theme-dark') ||
        bodyClasses.contains('theme-lights-out')
    ) {
        return 'dark';
    } else if (
        bodyClasses.contains('dim') ||
        bodyClasses.contains('theme-dim')
    ) {
        return 'dim';
    } else if (
        bodyClasses.contains('light') ||
        bodyClasses.contains('theme-light')
    ) {
        return 'light';
    }

    // Fallback: Check background color of the body
    // --- Changed line: Use doc.defaultView.getComputedStyle for jsdom compatibility ---
    const bodyBgColor = doc.defaultView.getComputedStyle(doc.body).backgroundColor;
    // console.log(`Body background color: ${bodyBgColor}`);
    if (bodyBgColor === 'rgb(0, 0, 0)') {
        // Lights Out / Dark
        return 'dark';
    } else if (bodyBgColor === 'rgb(21, 32, 43)') {
        // Dim (#15202B)
        return 'dim';
    } else if (bodyBgColor === 'rgb(255, 255, 255)') {
        // Light
        return 'light';
    }

    // Default to Light if all detection fails
    return 'light';
}

module.exports = detectTheme;

// File: src/utils/findReplyingToWithDepth.js
// --------------------------------
//Find divs containing text starting with 'Replying to '
//Find parent article container of each
//Return if vertical line is present: div class .r-1bnu78o
//TODO: add configuration argument to drive what we check for
//TODO: consider limiting nested depth like this: https://x.com/i/grok/share/2lwRYfwWMP7uguNodbpXhfd3K

function findReplyingToWithDepth(article) {

    function getInnerHTMLWithoutAttributes(element) {
        const clone = element.cloneNode(true);
        clone.querySelectorAll('*').forEach(el => {
            while (el.attributes.length > 0) {
                el.removeAttribute(el.attributes[0].name);
            }
        });
        return clone.innerHTML;
    }

    function findDivs(element, depth) {
        if (element.tagName === 'DIV') {
            if (element.innerHTML.startsWith('Replying to')) {
                result.push({
                    depth,
                    innerHTML: getInnerHTMLWithoutAttributes(element)
                        .replace(/<\/?(div|span)>/gi, '')
                });
            }
        }

        Array.from(element.children).forEach(child => findDivs(child, depth + 1));
    }
    
    const result = [];
    findDivs(article, 0);
    return result;
}

module.exports = findReplyingToWithDepth;

// File: src/utils/getRelativeLinkToPost.js
// --------------------------------
function getRelativeLinkToPost(element) {
    const link = element.querySelector('.css-146c3p1.r-1loqt21 time')?.parentElement?.getAttribute('href');
    return link || false;
}

module.exports = getRelativeLinkToPost;


// File: src/utils/identifyPost.js
// --------------------------------
const postHasProblemCommunity = require('./postHasProblemCommunity');
const postHasProblemSystemNotice = require('./postHasProblemSystemNotice');
const findReplyingToWithDepth = require('./findReplyingToWithDepth');
const getRelativeLinkToPost = require('./getRelativeLinkToPost');
const postQuality = require('./postQuality');

function identifyPost(post, checkReplies = false, providedLink = false) {
    // Check for first article (to avoid nested articles)
    const article = post.querySelector('article');
    if (!article) {
        return {
            quality: postQuality.UNDEFINED,
            reason: "No article found",
            link: providedLink,
        };
    }

    // Posts with system notices are problems
    const noticeFound = postHasProblemSystemNotice(article);
    if (noticeFound) {
        return {
            quality: postQuality.PROBLEM,
            reason: `Found notice: ${noticeFound}`,
            link: providedLink || getRelativeLinkToPost(post),
        };
    }

    // Posts with target communities are problems
    const communityFound = postHasProblemCommunity(article);
    if (communityFound) {
        return {
            quality: postQuality.PROBLEM,
            reason: `Found community: ${communityFound}`,
            link: providedLink || getRelativeLinkToPost(post),
        };
    }

    if (checkReplies) {
        // Posts with "Replying to" might be potential problems when found on with_replies page
        const link = getRelativeLinkToPost(post);
        const replyingToDepths = findReplyingToWithDepth(article);
        if (Array.isArray(replyingToDepths) && replyingToDepths.length > 0) {
            // Posts with replying to found at a depth < 10 are potential problems
            // console.log(replyingToDepths);
            const replyingTo = replyingToDepths.find(object => object.depth < 10);
            if (replyingTo) {

                return {
                    quality: postQuality.POTENTIAL_PROBLEM,
                    reason: `Found: '${replyingTo.innerHTML}' at a depth of ${replyingTo.depth}`,
                    link: providedLink || getRelativeLinkToPost(post),
                };
            }
        }
    }

    // By process of elimination, this is either good or undefined (likely filler info like "Click to see more replies").
    const link = providedLink || getRelativeLinkToPost(post);
    if (link) {
        return {
            quality: postQuality.GOOD,
            reason: "Looks good",
            link: link,
        };
    }

    return {
        quality: postQuality.UNDEFINED,
        reason: "Nothing to measure",
        link: providedLink,
    };
}

module.exports = identifyPost;

// File: src/utils/postHasProblemCommunity.js
// --------------------------------
function postHasProblemCommunity(article) {
    const communityIds = [
        "1889908654133911912"
    ];

    const aTags = Array.from(article.querySelectorAll('a'));
    for (const aTag of aTags) {
        for (const id of communityIds) {
            if (aTag.href.endsWith(`/i/communities/${id}`)) {
                return id;
            }
        }
    }
    return false; // Changed from "" to false
}

module.exports = postHasProblemCommunity;

// File: src/utils/postHasProblemSystemNotice.js
// --------------------------------
function postHasProblemSystemNotice(article) {
    const targetNotices = [
        "unavailable",
        "content warning",
        "this post is unavailable",
        "this post violated the x rules",
        "this post was deleted by the post author",
        "this post is from an account that no longer exists",
        "this post may violate x's rules against hateful conduct",
        "this media has been disabled in response to a report by the copyright owner",
        "you're unable to view this post"
    ];

    function normalizedTextContent(textContent) {
        return textContent
            .replace(/[‘’]/g, "'")
            .toLowerCase();
    }

    const spans = Array.from(article.querySelectorAll('span'));
    for (const span of spans) {
        const textContent = normalizedTextContent(span.textContent);
        for (const notice of targetNotices) {
            if (textContent.startsWith(notice)) {
                return notice;
            }
        }
    }
    return false;
}

module.exports = postHasProblemSystemNotice;

// File: src/utils/postQuality.js
// --------------------------------
const postQuality = Object.freeze({
    UNDEFINED: Object.freeze({ name: 'Undefined', value: 0 }),
    PROBLEM: Object.freeze({ name: 'Problem', value: 1 }),
    POTENTIAL_PROBLEM: Object.freeze({ name: 'Potential Problem', value: 2 }),
    GOOD: Object.freeze({ name: 'Good', value: 3 }),
});

module.exports = postQuality;


// File: src/utils/summarizeRatedPosts.js
// --------------------------------
const postQuality = require('./postQuality');

function summarizeRatedPosts(analyses) {
  // Initialize counters object using the enum values
  const summary = {
    [postQuality.UNDEFINED.name]: 0,
    [postQuality.PROBLEM.name]: 0,
    [postQuality.POTENTIAL_PROBLEM.name]: 0,
    [postQuality.GOOD.name]: 0
  };

  // Check if posts is valid and iterable
  if (!Array.isArray(analyses)) {
    return summary; // Return empty summary if posts is invalid
  }

  // Count each occurrence
  analyses.forEach(analysis => {
    if (analysis && analysis.quality && analysis.quality.name) {
      summary[analysis.quality.name]++;
    }
  });

  return summary;
}

module.exports = summarizeRatedPosts;

// File: src/xGhosted.js
// --------------------------------
// src/xGhosted.js

// Require the tested functions from their respective files
const getRelativeLinkToPost = require('./utils/getRelativeLinkToPost');
const postQuality = require('./utils/postQuality');
const detectTheme = require('./dom/detectTheme');
const identifyPost = require('./utils/identifyPost');

function XGhosted(doc) {
  this.state = {
      isWithReplies: false,
      postContainer: null,
      lastUrl: '',
      processedArticles: new Map(), // Key: post URL, Value: { status, checked, element, text, links }
  };
  this.document = doc;
}

XGhosted.prototype.updateState = function (url) {
  this.state.isWithReplies = /https:\/\/x\.com\/[^/]+\/with_replies/.test(url);
  if (this.state.lastUrl !== url) {
      this.state.postContainer = null;
      this.state.processedArticles.clear();
      this.state.lastUrl = url;
  }
};

XGhosted.prototype.findPostContainer = function () {
  if (this.state.postContainer) return this.state.postContainer;
  const posts = this.document.querySelectorAll('div[data-testid="cellInnerDiv"]');
  if (posts.length === 0) return null;
  this.state.postContainer = posts[0].parentElement;
  return this.state.postContainer;
};

XGhosted.prototype.identifyPosts = function () {
  // Get posts from the post container
  const container = this.findPostContainer();
  if (!container) return [];

  const posts = container.querySelectorAll('div[data-testid="cellInnerDiv"]');
  const results = [];

  posts.forEach(post => {
    const link = getRelativeLinkToPost(post) || `temp-id-${Math.random().toString(36).slice(2)}`; // Fallback ID for undefined posts
    const cached = this.state.processedArticles.get(link);

    if (cached && cached.element === post) {
      // Use cached result if the post element hasn’t changed
      results.push({ post, analysis: cached.analysis });
    } else {
      // Analyze and cache new or changed posts
      const analysis = identifyPost(post, this.state.isWithReplies, false);
      this.state.processedArticles.set(link, { analysis, element: post });
      results.push({ post, analysis });
    }
  });

  return results;
};

XGhosted.prototype.getThemeMode = function () {
  return detectTheme(this.document);
};

module.exports = XGhosted;

// File: src/xGhosted.test.js
// --------------------------------
const { JSDOM } = require('jsdom');
const XGhosted = require('./xGhosted');
const postQuality = require('./utils/postQuality');
const summarizeRatedPosts = require('./utils/summarizeRatedPosts');
const fs = require('fs'); // Add these
const path = require('path');

function setupJSDOM() {
  // Load the sample HTML fragment
  const samplePath = path.resolve(__dirname, '../samples/Search-Including-Post-No-Longer-Available.html');
  const sampleHtml = fs.readFileSync(samplePath, 'utf8');
  
  // Inject into <body>
  const html = `<!DOCTYPE html><html><body>${sampleHtml}</body></html>`;
  
  const dom = new JSDOM(html, {
    url: 'https://x.com/user/with_replies',
    resources: 'usable',
    runScripts: 'dangerously',
  });
  global.window = dom.window;
  global.document = dom.window.document;
  if (!dom.window.getComputedStyle) {
    dom.window.getComputedStyle = (el) => ({
      backgroundColor: 'rgb(255, 255, 255)',
      getPropertyValue: () => ''
    });
  }
  return dom;
}

describe('xGhosted', () => {
  let xGhosted, dom;

  beforeEach(() => {
    dom = setupJSDOM();
    xGhosted = new XGhosted(dom.window.document);
    xGhosted.updateState('https://x.com/user/with_replies');
  });

  afterEach(() => {
    dom.window.document.body.innerHTML = '';
  });

  test('updateState detects /with_replies URL', () => {
    expect(xGhosted.state.isWithReplies).toBe(true); // Already set in beforeEach
  });

  test('findPostContainer identifies correct container', () => {
    const container = xGhosted.findPostContainer();
    expect(container.querySelectorAll('article:not(article article)').length).toBe(6); // Matches sample
  });

  test('identifyPosts classifies posts and caches results', () => {
    expect(xGhosted.state.isWithReplies).toBe(true); // Already set in beforeEach
    expect(xGhosted.state.processedArticles.size).toEqual(0); // No posts cached

    const posts = xGhosted.identifyPosts();
    expect(posts.length).toBe(6); // Matches sample HTML summary from Home-Timeline-With-Reply-To-Repost-No-Longer-Available.html
    expect(xGhosted.state.processedArticles.size).toBe(6); // All posts cached

    const analyses = posts.map(p => p.analysis);
    expect(analyses).toEqual([
      {
        quality: postQuality.GOOD,
        reason: "Looks good",
        link: "/catturd2/status/1886191961670893917",
      },
      {
        quality: postQuality.GOOD,
        reason: "Looks good",
        link: "/catturd2/status/1886191251562606816",
      },
      {
        quality: postQuality.POTENTIAL_PROBLEM,
        reason: "Found: 'Replying to <a>@GuntherEagleman</a>and<a>@LeaderJohnThune</a>' at a depth of 6",
        link: "/catturd2/status/1886189049674616930",

      },
      {
        quality: postQuality.PROBLEM,
        reason: "Found notice: this post is unavailable",
        link: "/catturd2/status/1886188210524438792",
      },
      {
        quality: postQuality.GOOD,
        reason: "Looks good",
        link: "/catturd2/status/1886186665342849268",
      },
      {
        quality: postQuality.GOOD,
        reason: "Looks good",
        link: "/catturd2/status/1886185480791744705",
      }
    ]);

    // Check classifications against sample summary
    const summary = summarizeRatedPosts(analyses);
    expect(summary.Good).toBe(4);
    expect(summary.Problem).toBe(1);
    expect(summary['Potential Problem']).toBe(1);
    expect(summary.Undefined).toBe(0);

    // Re-run should return same results (cached)
    const postsAgain = xGhosted.identifyPosts();
    expect(postsAgain.length).toBe(6);
    expect(postsAgain[0].analysis).toEqual(posts[0].analysis); // Cached result
  });

  test.skip('collapsePosts hides problem posts', () => {
    const cells = xGhosted.findCollapsibleElements();
    xGhosted.state.lastCollapseTime = 0;
    xGhosted.collapsePosts();
    const problemPostCell = cells.find(cell =>
      cell.querySelector('article')?.innerHTML.includes('this post is unavailable')
    );
    expect(problemPostCell.style.display).toBe('none');
    expect(xGhosted.state.collapsedElements.size).toBeGreaterThan(0);
  });

  test.skip('highlightPosts applies correct borders', () => {
    xGhosted.highlightPosts();
    const posts = xGhosted.identifyPosts();
    const goodPost = posts.find(p => p.analysis.quality === postQuality.GOOD);
    const problemPost = posts.find(p => p.analysis.quality === postQuality.PROBLEM);
    const potentialPost = posts.find(p => p.analysis.quality === postQuality.POTENTIAL_PROBLEM);

    expect(goodPost.post.querySelector('article').style.border).toBe('none');
    expect(problemPost.post.querySelector('article').style.border).toBe('3px solid red');
    expect(potentialPost.post.querySelector('article').style.border).toBe('3px solid orange');
  });

  describe.skip('identifyPosts with sample HTML', () => {
    test('processes good and problem posts correctly', () => {
      const posts = xGhosted.identifyPosts();
      const problemPost = posts.find(p => p.analysis.quality === postQuality.PROBLEM);
      const goodPost = posts.find(p => p.analysis.quality === postQuality.GOOD);

      expect(problemPost).toBeDefined();
      expect(problemPost.analysis).toEqual({
        quality: postQuality.PROBLEM,
        reason: "Found notice: this post is unavailable",
        link: expect.stringContaining('/status/') // Dynamic status ID
      });
      expect(goodPost).toBeDefined();
      expect(goodPost.analysis.quality).toBe(postQuality.GOOD);
    });

    test('identifies all post qualities correctly', () => {
      const posts = xGhosted.identifyPosts();
      expect(posts.length).toBe(36); // Matches sample summary
      const goodPosts = posts.filter(p => p.analysis.quality === postQuality.GOOD);
      const problemPosts = posts.filter(p => p.analysis.quality === postQuality.PROBLEM);
      const potentialPosts = posts.filter(p => p.analysis.quality === postQuality.POTENTIAL_PROBLEM);
      const undefinedPosts = posts.filter(p => p.analysis.quality === postQuality.UNDEFINED);

      expect(goodPosts.length).toBe(21);
      expect(problemPosts.length).toBe(1);
      expect(potentialPosts.length).toBe(2);
      expect(undefinedPosts.length).toBe(12);
    });
  });

  describe('getThemeMode', () => {

    test('returns "dark" when data-theme includes "lights-out" or "dark"', () => {
      dom.window.document.body.setAttribute('data-theme', 'lights-out');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dark');

      dom.window.document.body.setAttribute('data-theme', 'dark');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dark');
    });

    test('returns "dim" when data-theme includes "dim"', () => {
      dom.window.document.body.setAttribute('data-theme', 'dim');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dim');
    });

    test('returns "light" when data-theme includes "light" or "default"', () => {
      dom.window.document.body.setAttribute('data-theme', 'light');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('light');

      dom.window.document.body.setAttribute('data-theme', 'default');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('light');
    });

    test('returns "dark" when body has dark classes', () => {
      dom.window.document.body.removeAttribute('data-theme'); // Ensure data-theme doesn’t interfere
      dom.window.document.body.classList.add('dark');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dark');
    });

    test('returns "dim" when body has dim classes', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.classList.add('dim');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dim');
    });

    test('returns "light" when body has light classes', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.classList.add('light');
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('light');
    });

    test('returns "dark" when background is rgb(0, 0, 0)', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.className = '';
      dom.window.document.body.style.backgroundColor = 'rgb(0, 0, 0)';
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dark');
    });

    test('returns "dim" when background is rgb(21, 32, 43)', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.className = '';
      dom.window.document.body.style.backgroundColor = 'rgb(21, 32, 43)';
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('dim');
    });

    test('returns "light" when background is rgb(255, 255, 255)', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.className = '';
      dom.window.document.body.style.backgroundColor = 'rgb(255, 255, 255)';
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('light');
    });

    test('returns "light" as default', () => {
      dom.window.document.body.removeAttribute('data-theme');
      dom.window.document.body.className = '';
      dom.window.document.body.style.backgroundColor = '';
      var xGhosted = new XGhosted(dom.window.document);
      expect(xGhosted.getThemeMode()).toBe('light');
    });
  });
});

