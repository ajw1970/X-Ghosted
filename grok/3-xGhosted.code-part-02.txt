        "   3 Posts",
        "   2 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (3 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   1 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: PROBLEM, reason: "Found notice: this post is unavailable", link: "/catturd2/status/1886210678752518230", },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/BarbieTrueBlue/status/1886211137961680919" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify this unable to view post problem in this nested article', () => {
      loadHTML('samples/You-Cant-View-This-Post.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   3 Posts",
        "   2 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (3 Total):",
        "   1 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   1 Undefined"
      ].join("\n"));

      // Extract analysis from each rated post
      expect(analyses).toEqual([
        { quality: PROBLEM, reason: "Found notice: you're unable to view this post", link: "/catturd2/status/1886210678752518230", },
        { quality: UNDEFINED, reason: "No article found", link: false, },
        { quality: GOOD, reason: "Looks good", link: "/BarbieTrueBlue/status/1886211137961680919", },
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify this unable to view post problem in this nested article', () => {
      loadHTML('samples/Reply-To-Repost-Of-Account-No-Longer-Exists.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "  29 Posts",
        "  20 Articles",
        "   1 Nested Articles",
        "",
        "Rated Post Quality (29 Total):",
        "  19 Good",
        "   0 Potential Problem",
        "   1 Problem",
        "   9 Undefined"
      ].join("\n"));

      expect(analyses[0]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900446828958470577" });
      expect(analyses[1]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/Name__Error_404/status/1900452964101402693" });
      expect(analyses[2]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900454996501475806" });
      expect(analyses[3]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[4]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/adamcarolla/status/1900417203356193038" });
      expect(analyses[5]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900454397697495122" });
      expect(analyses[6]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[7]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/klara_sjo/status/1900303399511318989" });
      expect(analyses[8]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900453954611232911" });
      expect(analyses[9]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[10]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/CNviolations/status/1900441767553446324" });
      expect(analyses[11]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900453039971971160" });
      expect(analyses[12]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[13]).toEqual({ "quality": PROBLEM, "reason": "Found notice: this post is from an account that no longer exists", "link": "/_____USA___/status/1900433669036405235" });
      expect(analyses[14]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900452749206044700" });
      expect(analyses[15]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[16]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/CultureCrave/status/1900440715806859351" });
      expect(analyses[17]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900452224620179640" });
      expect(analyses[18]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[19]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/MagneticNorse/status/1900444331082690813" });
      expect(analyses[20]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900451349776490691" });
      expect(analyses[21]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[22]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/WallStreetMav/status/1900437991761563894" });
      expect(analyses[23]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900450032354025709" });
      expect(analyses[24]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[25]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/charliekirk11/status/1900284625467170868" });
      expect(analyses[26]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/ApostleJohnW/status/1900449357188546773" });
      expect(analyses[27]).toEqual({ "quality": UNDEFINED, "reason": "No article found", "link": false });
      expect(analyses[28]).toEqual({ "quality": GOOD, "reason": "Looks good", "link": "/gunsnrosesgirl3/status/1900423541561962874" });

      document.documentElement.innerHTML = '';
    });

  });

});

describe('identifyPosts - Potential Problems', () => {

  describe('potential problem posts identified with findReplyingToWithDepth', () => {

    it('should identify one potential problem reply in this single post', () => {
      loadHTML('samples/Home-Timeline-SingleExample.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   1 Posts",
        "   1 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (1 Total):",
        "   0 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([{ quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@KanekoaTheGreat</a>' at a depth of 6", link: "/ApostleJohnW/status/1890213085878845626" }]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this sample size of 23', () => {
      loadHTML('samples/Home-Timeline-With-Replies-SeparateButRelated.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "  23 Posts",
        "  16 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (23 Total):",
        "  15 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   7 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/Polymarket/status/1890150272015692285" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890268189273256429" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/joerogan/status/1890256988065747120" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890267922888831056" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/elonmusk/status/1890267219021689066" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890267836297408744" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/fasc1nate/status/1890159112966529049" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890266335059538298" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890226210656968925" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/KanekoaTheGreat/status/1890210084158103579" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890213612868063403" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@KanekoaTheGreat</a>' at a depth of 6", link: "/ApostleJohnW/status/1890213085878845626" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890201310458216496" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/amuse/status/1890188509212021011" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890197334828470528" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/GuntherEagleman/status/1890193877270737033" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this sample size of 8', () => {
      loadHTML('samples/Home-Timeline-With-Replies-With-Suspect-Reply-To-DOGE.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   8 Posts",
        "   5 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (8 Total):",
        "   4 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   3 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890582770079928347" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/realchrisrufo/status/1890461003453972704" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890582075989737603" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@DOGE</a>' at a depth of 6", link: "/ApostleJohnW/status/1890581864882065729" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/Starlink/status/1890556777910981087" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this sample size of 9', () => {
      loadHTML('samples/Home-Timeline-With-Replies-With-Suspect-Reply-To-TheRabbitHole84.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   9 Posts",
        "   7 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (9 Total):",
        "   6 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   2 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/TomHoman_/status/1890264842021531908" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890492039311114515" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/TRHLofficial/status/1890488779200135602" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890489017642127402" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@TheRabbitHole84</a>' at a depth of 6", link: "/ApostleJohnW/status/1890483565499932926" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890477786164318696" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1890477475659927947" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this sample size of 28', () => {
      loadHTML('samples/Home-Timeline-With-Replies-With-Suspect-Reply.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "  28 Posts",
        "  18 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (28 Total):",
        "  17 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "  10 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897284088387535306" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/ArthurMacwaters/status/1897070572934439349" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/ArthurMacwaters/status/1897274644358693224" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897277949675733193" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/cgallaty/status/1897270300171231704" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/cgallaty/status/1897274689350729929" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897274953936117962" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@cgallaty</a>' at a depth of 6", link: "/ApostleJohnW/status/1897274769164431494" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/ArthurMacwaters/status/1897267322261528696" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897274123841090000" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/BasedMikeLee/status/1897263908613971994" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897267944742384013" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/BreannaMorello/status/1897264239783633229" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897266164189040752" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/piersmorgan/status/1897261181653627162" },
        { quality: GOOD, reason: "Looks good", link: "/DrEtiquette/status/1897264279868596522" },
        { quality: GOOD, reason: "Looks good", link: "/ApostleJohnW/status/1897265836777513106" },
        { quality: UNDEFINED, reason: "No article found", link: false },
        { quality: GOOD, reason: "Looks good", link: "/Gutfeldfox/status/1896996720460095926" }
      ]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this single post', () => {
      loadHTML('samples/Replying-To-Suspicious-Example (2).html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   1 Posts",
        "   1 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (1 Total):",
        "   0 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([{ quality: POTENTIAL_PROBLEM, link: "/ApostleJohnW/status/1890483565499932926", reason: "Found: 'Replying to <a>@TheRabbitHole84</a>' at a depth of 6", }]);

      document.documentElement.innerHTML = '';
    });

    it('should identify one potential problem reply in this single post', () => {
      loadHTML('samples/Replying-To-Suspicious-Example.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   1 Posts",
        "   1 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (1 Total):",
        "   0 Good",
        "   1 Potential Problem",
        "   0 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([{ quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@TheRabbitHole84</a>' at a depth of 6", link: "/ApostleJohnW/status/1890483565499932926", }]);

      document.documentElement.innerHTML = '';
    });

    it('should find four potential problem replies in this sample size of 7', () => {
      loadHTML('samples/Search-With-Unlinked-Replying-To-Handle.html');
      const analyses = identifyPosts(document);

      expect(describeSampleAnalyses(document, analyses)).toBe([
        "Structure Summary Totals:",
        "   7 Posts",
        "   7 Articles",
        "   0 Nested Articles",
        "",
        "Rated Post Quality (7 Total):",
        "   3 Good",
        "   4 Potential Problem",
        "   0 Problem",
        "   0 Undefined"
      ].join("\n"));

      expect(analyses).toEqual([
        { link: "/ApostleJohnW/status/1878550122281185320", quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@Yelp</a>' at a depth of 6", },
        { link: "/ApostleJohnW/status/1878503220315566322", quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@ApostleJohnW</a>' at a depth of 6", },
        { link: "/ApostleJohnW/status/1878503164703379943", quality: GOOD, reason: "Looks good", },
        { link: "/ApostleJohnW/status/1878492936129650980", quality: GOOD, reason: "Looks good", },
        { link: "/ApostleJohnW/status/1878451643068391847", quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@ApostleJohnW</a>@LorraineMarie71and<a>@ApostleEric</a>' at a depth of 6", },
        { link: "/ApostleJohnW/status/1878432165748220160", quality: GOOD, reason: "Looks good", },
        { link: "/ApostleJohnW/status/1878371966513500444", quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@ApostleJohnW</a>' at a depth of 6", },
      ]);

      document.documentElement.innerHTML = '';
    });

  });

});

describe('identifyPosts - Problems and Potential Problems', () => {

  it('should identify one potential problem reply and one problem post in this sample size of 6 with one nested article', () => {
    loadHTML('samples/Search-Including-Post-No-Longer-Available.html');
    const analyses = identifyPosts(document);

    expect(describeSampleAnalyses(document, analyses)).toBe([
      "Structure Summary Totals:",
      "   6 Posts",
      "   6 Articles",
      "   1 Nested Articles",
      "",
      "Rated Post Quality (6 Total):",
      "   4 Good",
      "   1 Potential Problem",
      "   1 Problem",
      "   0 Undefined"
    ].join("\n"));

    expect(analyses).toEqual([
      { quality: GOOD, reason: "Looks good", link: "/catturd2/status/1886191961670893917", },
      { quality: GOOD, reason: "Looks good", link: "/catturd2/status/1886191251562606816", },
      { quality: POTENTIAL_PROBLEM, reason: "Found: 'Replying to <a>@GuntherEagleman</a>and<a>@LeaderJohnThune</a>' at a depth of 6", link: "/catturd2/status/1886189049674616930", },
      { quality: PROBLEM, reason: "Found notice: this post is unavailable", link: "/catturd2/status/1886188210524438792", },
      { quality: GOOD, reason: "Looks good", link: "/catturd2/status/1886186665342849268", },
      { quality: GOOD, reason: "Looks good", link: "/catturd2/status/1886185480791744705", }
    ]);

    document.documentElement.innerHTML = '';
  });

});

// File: src/utils/postHasProblemCommunity.js
// --------------------------------
function postHasProblemCommunity(article) {
    const communityIds = [
        "1889908654133911912"
    ];

    const aTags = Array.from(article.querySelectorAll('a'));
    for (const aTag of aTags) {
        for (const id of communityIds) {
            if (aTag.href.endsWith(`/i/communities/${id}`)) {
                return id;
            }
        }
    }
    return false; // Changed from "" to false
}

export { postHasProblemCommunity };

// File: src/utils/postHasProblemCommunity.test.js
// --------------------------------
import { postHasProblemCommunity } from './postHasProblemCommunity';
import { JSDOM } from 'jsdom';

describe('postHasProblemCommunity', () => {
    const dom = new JSDOM('<!DOCTYPE html><div></div>');
    global.document = dom.window.document;

    function createArticle(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div;
    }

    test('returns ID when community link found', () => {
        const article = createArticle('<a href="https://x.com/i/communities/1889908654133911912">Link</a>');
        const result = postHasProblemCommunity(article);
        expect(result).toBe('1889908654133911912');
    });

    test('returns false when no community link found', () => {
        const article = createArticle('<a href="https://x.com/user">Link</a>');
        const result = postHasProblemCommunity(article);
        expect(result).toBe(false);
    });

    test('returns false for empty article', () => {
        const article = createArticle('');
        const result = postHasProblemCommunity(article);
        expect(result).toBe(false);
    });
});

// File: src/utils/postHasProblemSystemNotice.js
// --------------------------------
function postHasProblemSystemNotice(article) {
    const targetNotices = [
        "unavailable",
        "content warning",
        "this post is unavailable",
        "this post violated the x rules",
        "this post was deleted by the post author",
        "this post is from an account that no longer exists",
        "this post may violate x's rules against hateful conduct",
        "this media has been disabled in response to a report by the copyright owner",
        "you're unable to view this post"
    ];

    function normalizedTextContent(textContent) {
        return textContent
            .replace(/[â€˜â€™]/g, "'")
            .toLowerCase();
    }

    const spans = Array.from(article.querySelectorAll('span'));
    for (const span of spans) {
        const textContent = normalizedTextContent(span.textContent);
        for (const notice of targetNotices) {
            if (textContent.startsWith(notice)) {
                return notice;
            }
        }
    }
    return false;
}

export { postHasProblemSystemNotice };

// File: src/utils/postHasProblemSystemNotice.test.js
// --------------------------------
import { postHasProblemSystemNotice } from './postHasProblemSystemNotice';
import { JSDOM } from 'jsdom';

describe('postHasProblemSystemNotice', () => {

    const dom = new JSDOM('<!DOCTYPE html><div></div>');
    global.document = dom.window.document;

    function createArticle(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div;
    }

    test('returns notice when present', () => {
        const article = createArticle('<span>This post is unavailable</span>');
        const result = postHasProblemSystemNotice(article);
        expect(result).toBe('this post is unavailable');
    });

    test('returns false when no notice found', () => {
        const article = createArticle('<span>Hello world</span>');
        const result = postHasProblemSystemNotice(article);
        expect(result).toBe(false);
    });

    test('handles curly apostrophes', () => {
        const article = createArticle('<span>Youâ€™re unable to view this post</span>');
        const result = postHasProblemSystemNotice(article);
        expect(result).toBe("you're unable to view this post");
    });

    test('returns false for empty article', () => {
        const article = createArticle('');
        const result = postHasProblemSystemNotice(article);
        expect(result).toBe(false);
    });
});

// File: src/utils/postQuality.js
// --------------------------------
const postQuality = Object.freeze({
    UNDEFINED: Object.freeze({ name: 'Undefined', value: 0 }),
    PROBLEM: Object.freeze({ name: 'Problem', value: 1 }),
    POTENTIAL_PROBLEM: Object.freeze({ name: 'Potential Problem', value: 2 }),
    GOOD: Object.freeze({ name: 'Good', value: 3 }),
});

export { postQuality };


// File: src/utils/summarizeRatedPosts.js
// --------------------------------
import { postQuality } from './postQuality';

function summarizeRatedPosts(analyses) {
  // Initialize counters object using the enum values
  const summary = {
    [postQuality.UNDEFINED.name]: 0,
    [postQuality.PROBLEM.name]: 0,
    [postQuality.POTENTIAL_PROBLEM.name]: 0,
    [postQuality.GOOD.name]: 0
  };

  // Check if posts is valid and iterable
  if (!Array.isArray(analyses)) {
    return summary; // Return empty summary if posts is invalid
  }

  // Count each occurrence
  analyses.forEach(analysis => {
    if (analysis && analysis.quality && analysis.quality.name) {
      summary[analysis.quality.name]++;
    }
  });

  return summary;
}

export { summarizeRatedPosts };

// File: src/xGhosted.js
// --------------------------------
import { postQuality } from './utils/postQuality.js';
import { detectTheme } from './dom/detectTheme';
import { identifyPost } from './utils/identifyPost';
import { debounce } from './utils/debounce';
import { findPostContainer } from './dom/findPostContainer.js';
import { getRelativeLinkToPost } from './utils/getRelativeLinkToPost.js';
import { parseUrl } from './dom/parseUrl.js';

function XGhosted(doc, config = {}) {
  const defaultTiming = {
    debounceDelay: 500,
    throttleDelay: 1000,
    tabCheckThrottle: 5000,
    exportThrottle: 5000,
    pollInterval: 1000,
    scrollInterval: 1500,
  };
  this.timing = { ...defaultTiming, ...config.timing };
  this.document = doc;
  this.log = config.log || console.log.bind(console);
  if (!config.postsManager) {
    throw new Error('XGhosted requires a postsManager instance');
  }
  this.postsManager = config.postsManager;
  this.state = {
    postContainer: null,
    lastUrlFullPath: '',
    isWithReplies: false,
    isRateLimited: false,
    isAutoScrollingEnabled: false,
    isHighlighting: false,
    isPollingEnabled: true,
    userProfileName: null,
  };
  this.checkPostInNewTabThrottled = debounce((href) => {
    return this.checkPostInNewTab(href);
  }, this.timing.tabCheckThrottle);
  this.highlightPostsDebounced = debounce(() => {
    this.highlightPosts();
  }, this.timing.debounceDelay);
}

XGhosted.POST_CONTAINER_SELECTOR = 'div[data-xghosted="posts-container"]';
XGhosted.UNPROCESSED_POSTS_SELECTOR = `${XGhosted.POST_CONTAINER_SELECTOR} div[data-testid="cellInnerDiv"]:not([data-xghosted-id])`;

XGhosted.prototype.getUrlFullPathIfChanged = function (url) {
  const urlParts = new URL(url);
  const urlFullPath = urlParts.origin + urlParts.pathname;
  if (this.state.lastUrlFullPath === urlFullPath) {
    return false;
  }

  this.log(`URL has changed from (${this.state.lastUrlFullPath}) to (${urlFullPath})`);
  this.state.lastUrlFullPath = urlFullPath;
  return urlFullPath;
};

XGhosted.prototype.handleUrlChange = function (urlFullPath) {
  const { isWithReplies, userProfileName } = parseUrl(urlFullPath);
  this.state.isWithReplies = isWithReplies;
  if (this.state.userProfileName !== userProfileName) {
    this.state.userProfileName = userProfileName;
    this.document.dispatchEvent(new CustomEvent('xghosted:user-profile-updated', {
      detail: {
        userProfileName: this.state.userProfileName
      }
    }));
  }

  this.postsManager.clearPosts();
}

XGhosted.prototype.checkPostInNewTab = function (href) {
  this.log(`Checking post in new tab: ${href}`);
  const fullUrl = `${this.postsManager.linkPrefix}${href}`;
  const newWindow = this.document.defaultView.open(fullUrl, '_blank');
  let attempts = 0;
  const maxAttempts = 10;
  return new Promise((resolve) => {
    const checkInterval = setInterval(() => {
      attempts++;
      if (newWindow && newWindow.document.readyState === 'complete') {
        const doc = newWindow.document;
        if (doc.body.textContent.includes('Rate limit exceeded')) {
          clearInterval(checkInterval);
          this.log('Rate limit detected, pausing operations');
          this.state.isRateLimited = true;
          newWindow.close();
          setTimeout(() => {
            this.log('Resuming after rate limit pause');
            this.state.isRateLimited = false;
            resolve(false);
          }, this.timing.rateLimitPause);
          return;
        }
        const targetPost = doc.querySelector(`[data-xghosted-id="${href}"]`);
        if (targetPost) {
          this.log(`Original post found in new tab: ${href}`);
          clearInterval(checkInterval);
          const hasProblem = doc.querySelector('[data-xghosted="postquality.problem"]') !== null;
          if (hasProblem) {
            newWindow.scrollTo(0, 0);
            this.log(`Problem found in thread at ${href}`);
          } else {
            newWindow.close();
            this.log(`No problem found in thread at ${href}`);
          }
          resolve(hasProblem);
        }
      }
      if (attempts >= maxAttempts) {
        clearInterval(checkInterval);
        if (newWindow) newWindow.close();
        this.log(`Failed to process ${href} within ${maxAttempts} attempts`);
        resolve(false);
      }
    }, 500);
  });
};

XGhosted.prototype.userRequestedPostCheck = function (href, post) {
  this.log(`User requested check for ${href}`);
  const cached = this.postsManager.getPost(href);
  if (!cached || cached.analysis.quality.name !== postQuality.POTENTIAL_PROBLEM.name) {
    this.log(`Manual check skipped for ${href}: not a potential problem`);
    return;
  }
  if (!cached.checked) {
    this.handleStopPolling();
    this.log(`Manual check starting for ${href}`);
    this.checkPostInNewTab(href).then((isProblem) => {
      this.log(`Manual check result for ${href}: ${isProblem ? 'problem' : 'good'}`);
      const currentPost = this.document.querySelector(`[data-xghosted-id="${href}"]`);
      if (!currentPost) {
        this.log(`Post with href ${href} no longer exists in the DOM, skipping DOM update`);
      } else {
        currentPost.classList.remove('xghosted-potential_problem', 'xghosted-good', 'xghosted-problem');
        currentPost.classList.add(isProblem ? 'xghosted-problem' : 'xghosted-good');
        currentPost.setAttribute('data-xghosted', `postquality.${isProblem ? 'problem' : 'good'}`);
        const eyeballContainer = currentPost.querySelector('.xghosted-eyeball');
        if (eyeballContainer) {
          eyeballContainer.classList.remove('xghosted-eyeball');
        } else {
          this.log(`Eyeball container not found for post with href: ${href}`);
        }
      }
      cached.analysis.quality = isProblem ? postQuality.PROBLEM : postQuality.GOOD;
      cached.checked = true;
      this.postsManager.registerPost(href, cached);
      this.document.dispatchEvent(
        new CustomEvent('xghosted:state-updated', {
          detail: { ...this.state }
        })
      );
      this.log(`User requested post check completed for ${href}`);
    });
  } else {
    this.log(`Manual check skipped for ${href}: already checked`);
  }
};

XGhosted.prototype.handleStartPolling = function () {
  this.state.isPollingEnabled = true;
  this.startPolling();
  this.startAutoScrolling();
  this.document.dispatchEvent(
    new CustomEvent('xghosted:polling-state-updated', {
      detail: { isPollingEnabled: this.state.isPollingEnabled }
    })
  );
};

XGhosted.prototype.handleStopPolling = function () {
  this.state.isPollingEnabled = false;
  if (this.pollTimer) {
    clearInterval(this.pollTimer);
    this.pollTimer = null;
  }
  if (this.scrollTimer) {
    clearInterval(this.scrollTimer);
    this.scrollTimer = null;
  }
  this.document.dispatchEvent(
    new CustomEvent('xghosted:polling-state-updated', {
      detail: { isPollingEnabled: this.state.isPollingEnabled }
    })
  );
};

XGhosted.prototype.startPolling = function () {
  if (!this.state.isPollingEnabled) {
    this.log('Polling not started: polling is disabled');
    return;
  }
  const pollInterval = this.timing.pollInterval || 1000;
  this.log('Starting polling for post changes...');
  this.pollTimer = setInterval(() => {

    if (this.state.isHighlighting) {
      this.log('Polling skippedâ€”highlighting in progress');
      return;
    }

    // Check for URL changes
    const urlFullPath = this.getUrlFullPathIfChanged(this.document.location.href);
    if (urlFullPath) {
      this.log(`URL has changed from (${this.state.lastUrlFullPath}) to (${urlFullPath})`);
      this.handleUrlChange(urlFullPath);
    }

    // Assuming we've handled any change to the URL origin, we can check for posts
    const unprocessedPosts = this.document.querySelectorAll(XGhosted.UNPROCESSED_POSTS_SELECTOR);
    if (unprocessedPosts.length > 0) {
      this.highlightPosts(unprocessedPosts);
    } else if (!this.document.querySelector(XGhosted.POST_CONTAINER_SELECTOR)) {
      this.log('No post container found, trying to find it...');
      const foundContainer = findPostContainer(this.document, this.log);
      if (foundContainer) {
        this.highlightPosts();
      } else {
        this.log('Container still not found, skipping highlighting');
      }
    } else {
      // this.log('No unprocessed posts found, skipping highlighting');
    }
  }, pollInterval);
};

XGhosted.prototype.startAutoScrolling = function () {
  if (!this.state.isPollingEnabled) {
    this.log('Auto-scrolling not started: polling is disabled');
    return;
  }
  const scrollInterval = this.timing.scrollInterval || 3000;
  this.log('Starting auto-scrolling timer...');
  this.scrollTimer = setInterval(() => {
    if (!this.state.isPollingEnabled) {
      this.log('Auto-scrolling skippedâ€”polling is disabled');
      return;
    }
    if (this.state.isAutoScrollingEnabled) {
      const scrollHeight = this.document.documentElement.scrollHeight;
      const scrollTop = window.scrollY + window.innerHeight;
      if (scrollTop >= scrollHeight - 10) { // Small buffer
        this.log('Reached page bottom, stopping auto-scrolling');
        this.toggleAutoScrolling();
        return;
      }
      // this.log('Performing smooth scroll down...');
      window.scrollBy({
        top: window.innerHeight * 0.8,
        behavior: 'smooth'
      });
    }
  }, scrollInterval);
};

XGhosted.prototype.toggleAutoScrolling = function () {
  this.state.isAutoScrollingEnabled = !this.state.isAutoScrollingEnabled;
  this.document.dispatchEvent(
    new CustomEvent('xghosted:auto-scrolling-toggled', {
      detail: { isAutoScrollingEnabled: this.state.isAutoScrollingEnabled }
    })
  );
};

XGhosted.prototype.expandArticle = function (article) {
  if (article) {
    article.style.height = 'auto';
    article.style.overflow = 'visible';
    article.style.margin = 'auto';
    article.style.padding = 'auto';
  }
};

XGhosted.prototype.highlightPosts = function (posts) {
  this.state.isHighlighting = true;

  const processPostAnalysis = (post, analysis) => {
    if (!(post instanceof this.document.defaultView.Element)) {
      this.log('Skipping invalid DOM element:', post);
      return;
    }
    const id = analysis.link;
    const qualityName = analysis.quality.name.toLowerCase().replace(' ', '_');
    post.setAttribute('data-xghosted-id', id);
    post.setAttribute('data-xghosted', `postquality.${qualityName}`);
    post.classList.add(`xghosted-${qualityName}`);
    if (analysis.quality === postQuality.POTENTIAL_PROBLEM) {
      const shareButtonContainer = post.querySelector('button[aria-label="Share post"]')?.parentElement;
      if (shareButtonContainer) {
        shareButtonContainer.classList.add('xghosted-eyeball');
      } else {
        this.log(`No share button container found for post with href: ${id}`);
      }
    }
    if (id) {
      this.postsManager.registerPost(id, { analysis, checked: false });
    }
  };

  const checkReplies = this.state.isWithReplies;
  const userProfileName = this.state.userProfileName;
  const results = [];
  const postsToProcess = posts || this.document.querySelectorAll(XGhosted.UNPROCESSED_POSTS_SELECTOR);
  let postsProcessed = 0;
  let cachedAnalysis = false;
  postsToProcess.forEach((post) => {
    const postId = getRelativeLinkToPost(post);
    if (postId) {
      const cachedPost = this.postsManager.getPost(postId);
      cachedAnalysis = cachedPost?.analysis;
    }
    let analysis = cachedAnalysis ? { ...cachedAnalysis } : identifyPost(post, checkReplies);
    if (analysis?.quality === postQuality.PROBLEM) {
      this.handleStopPolling();
    }
    if (!cachedAnalysis) postsProcessed++;
    processPostAnalysis(post, analysis);
    results.push(analysis);
  });
  if (postsProcessed > 0) {
    this.document.dispatchEvent(
      new CustomEvent('xghosted:state-updated', {
        detail: { ...this.state }
      })
    );
    this.log(`Highlighted ${postsProcessed} new posts, state-updated emitted`);
  }
  this.state.isHighlighting = false;
  return results;
};

XGhosted.prototype.getThemeMode = function () {
  return detectTheme(this.document);
};

XGhosted.prototype.init = function () {
  this.log('Initializing XGhosted...');
  if (this.document.body) {
    const themeMode = this.getThemeMode();
    this.document.dispatchEvent(new CustomEvent('xghosted:theme-detected', {
      detail: { themeMode }
    }));
  } else {
    this.log('Document body not available for theme detection');
  }
  this.document.dispatchEvent(new CustomEvent('xghosted:init', {
    detail: {
      config: {
        pollInterval: this.timing.pollInterval,
        scrollInterval: this.timing.scrollInterval
      }
    }
  }));

  const styleSheet = this.document.createElement('style');
  styleSheet.textContent = `
    .xghosted-good { border: 2px solid green; background: rgba(0, 255, 0, 0.1); }
    .xghosted-problem { border: 2px solid red; background: rgba(255, 0, 0, 0.1); }
    .xghosted-undefined { border: 2px solid gray; background: rgba(128, 128, 128, 0.1); }
    .xghosted-potential_problem { border: 2px solid yellow; background: rgba(255, 255, 0, 0.1); }
    .xghosted-collapsed { height: 0px; overflow: hidden; margin: 0; padding: 0; }
    .xghosted-eyeball::after {
      content: 'ðŸ‘€';
      color: rgb(29, 155, 240);
      padding: 8px;
      cursor: pointer;
      text-decoration: none;
    }
  `;
  this.document.head.appendChild(styleSheet);
  this.document.addEventListener('click', (e) => {
    const eyeball = e.target.closest('.xghosted-eyeball') ||
      (e.target.classList.contains('xghosted-eyeball') ? e.target : null);
    if (eyeball) {
      e.preventDefault();
      e.stopPropagation();
      this.log('Eyeball clicked! Digging in...');
      const clickedPost = eyeball.closest('div[data-xghosted-id]');
      const href = clickedPost?.getAttribute('data-xghosted-id');
      if (!href) {
        this.log('No href found for clicked eyeball');
        return;
      }
      this.log(`Processing eyeball click for: ${href}`);
      if (this.state.isRateLimited) {
        this.log(`Eyeball click skipped for ${href} due to rate limit`);
        return;
      }
      const cached = this.postsManager.getPost(href);
      this.userRequestedPostCheck(href, clickedPost);
    }
  }, { capture: true });
  this.startPolling();
  this.startAutoScrolling();
};

window.XGhosted = XGhosted;

export { XGhosted };

// File: src/xGhosted.template.js
// --------------------------------
// ==UserScript==
// @name         xGhosted{{Suffix}}
// @namespace    http://tampermonkey.net/
// @version      {{VERSION}}
// @description  Highlight and manage problem posts on X.com with a resizable, draggable panel
// @author       You
// @match        https://x.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=x.com
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_log
// @require      https://unpkg.com/preact@10.26.4/dist/preact.min.js
// @require      https://unpkg.com/preact@10.26.4/hooks/dist/hooks.umd.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js
// @run-at       document-idle
// ==/UserScript==

(function () {
  'use strict';

  // Safety check: Ensure we're on X.com with a valid document
  const log = typeof GM_log !== 'undefined' ? GM_log : console.log.bind(console);
  if (!window.location.href.startsWith('https://x.com/') || !document.body) {
    log('xGhosted: Aborting - invalid environment');
    return;
  }

  // Log startup with safety focus
  log('xGhosted v{{VERSION}} starting - Manual mode on, resource use capped, rate limit pause set to 20 seconds');

  // Check if Preact and Preact Hooks dependencies loaded
  if (!window.preact || !window.preactHooks) {
    log(
      'xGhosted: Aborting - Failed to load dependencies. Preact: ' +
      (window.preact ? 'loaded' : 'missing') +
      ', Preact Hooks: ' +
      (window.preactHooks ? 'loaded' : 'missing')
    );
    return;
  }

  // Check if Font Awesome loaded
  if (typeof window.FontAwesome === 'undefined') {
    log('xGhosted: Font Awesome failed to load, icons may not display correctly');
  }

  // --- Inject Shared Utilities ---
  // INJECT: Utils

  // --- Inject Modules ---
  // INJECT: xGhosted
  // INJECT: SplashPanel
  // INJECT: PanelManager
  // INJECT: ProcessedPostsManager

  // --- Inject Styles ---
  // INJECT: Styles

  // --- Initialization with Resource Limits and Rate Limiting ---
  const RATE_LIMIT_PAUSE = 20 * 1000; // 20 seconds in milliseconds
  const postsManager = new window.ProcessedPostsManager({
    storage: {
      get: GM_getValue,
      set: GM_setValue
    },
    log,
    linkPrefix: 'https://x.com'
  });
  const config = {
    timing: {
      debounceDelay: 500,
      throttleDelay: 1000,
      tabCheckThrottle: 5000,
      exportThrottle: 5000,
      rateLimitPause: RATE_LIMIT_PAUSE,
      pollInterval: 1000
    },
    showSplash: true,
    log, // Pass logger
    postsManager
  };
  const xGhosted = new window.XGhosted(document, config);
  xGhosted.state.isManualCheckEnabled = true;

  // Initialize SplashPanel with version only if showSplash is true
  let splashPanel = null;
  if (config.showSplash) {
    splashPanel = new window.SplashPanel(document, log, '{{VERSION}}');
  }

  // Wait for theme detection to initialize PanelManager
  document.addEventListener('xghosted:theme-detected', ({ detail: { themeMode } }) => {
    try {
      const panelManager = new window.PanelManager(
        document,
        xGhosted,
        themeMode || 'light',
        postsManager,
        { get: GM_getValue, set: GM_setValue }
      );
      log('GUI Panel initialized successfully');

      // Wire UI events to handlers
      document.addEventListener('xghosted:toggle-panel-visibility', ({ detail: { isPanelVisible } }) => {
        panelManager.toggleVisibility(isPanelVisible);
      });
      document.addEventListener('xghosted:copy-links', () => {
        panelManager.copyLinks();
      });
      document.addEventListener('xghosted:export-csv', () => {
        panelManager.exportProcessedPostsCSV();
      });
      document.addEventListener('xghosted:clear-posts', () => {
        panelManager.clearPosts();
      });
      document.addEventListener('xghosted:csv-import', ({ detail: { csvText } }) => {
        panelManager.importProcessedPostsCSV(csvText, () => { });
      });
    } catch (error) {
      log(`Failed to initialize GUI Panel: ${error.message}. Continuing without panel.`);
    }
  }, { once: true });

  xGhosted.init();
})();

// File: src/xGhosted.test.js
// --------------------------------
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import { JSDOM } from 'jsdom';
import { XGhosted } from './xGhosted.js';
import { postQuality } from './utils/postQuality.js';
import { summarizeRatedPosts } from './utils/summarizeRatedPosts.js';
import * as identifyPostModule from './utils/identifyPost.js';
import { findPostContainer } from './dom/findPostContainer.js';

// Mock the identifyPost module globally with async import
vi.mock('./utils/identifyPost.js', async () => {
  const actual = await vi.importActual('./utils/identifyPost.js');
  return {
    ...actual,
    identifyPost: vi.fn(actual.identifyPost),
  };
});

// Mock Tampermonkey GM_* functions
const gmStorage = {};
global.GM_getValue = vi.fn((key, defaultValue) => gmStorage[key] ?? defaultValue);
global.GM_setValue = vi.fn((key, value) => { gmStorage[key] = value; });

// ES6-compatible __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Mock window.alert
global.alert = vi.fn();

let clipboardMock;

function setupJSDOM() {
  const samplePath = resolve(__dirname, '../samples/Home-Timeline-With-Reply-To-Repost-No-Longer-Available.html');
  const sampleHtml = readFileSync(samplePath, 'utf8');
  const html = `<!DOCTYPE html><html><body>${sampleHtml}</body></html>`;
  const dom = new JSDOM(html, {
    url: 'https://x.com/user/with_replies',
    resources: 'usable',
    runScripts: 'dangerously',
  });
  global.window = dom.window;
  global.document = dom.window.document;
  dom.window.document.defaultView.open = vi.fn();
  dom.window.alert = vi.fn();
  clipboardMock = { writeText: vi.fn().mockResolvedValue() };
  dom.window.navigator = { clipboard: clipboardMock, userAgent: 'vitest' };
  global.navigator = dom.window.navigator;
  dom.window.URL = {
    createObjectURL: vi.fn(() => 'blob://test'),
    revokeObjectURL: vi.fn(),
  };
  return dom;
}

describe('xGhosted', () => {
  let xGhosted, dom;

  beforeAll(async () => {
    vi.useFakeTimers();
  });

  beforeEach(async () => {
    dom = setupJSDOM();
    xGhosted = new XGhosted(dom.window.document, {
      timing: { debounceDelay: 0, throttleDelay: 0, tabCheckThrottle: 0, exportThrottle: 0, rateLimitPause: 100 },
      useTampermonkeyLog: false,
      persistProcessedPosts: true,
    });
    xGhosted.handleUrlChange('https://x.com/user/with_replies');
    xGhosted.highlightPostsDebounced = xGhosted.highlightPosts; // Simplify for tests
    xGhosted.state.processedPosts.clear();
    xGhosted.state = {
      ...xGhosted.state,
      themeMode: 'dark',
      isManualCheckEnabled: false,
      userProfileName: 'user'
    };
  }, 30000);

  afterEach(() => {
    dom.window.document.body.innerHTML = '';
    vi.clearAllMocks();
  });

  test('checkPostInNewTab handles rate limit', async () => {
    xGhosted.state.isManualCheckEnabled = true;
    xGhosted.state.themeMode = 'dark';
    const mockWindow = {
      document: { readyState: 'complete', querySelectorAll: () => [], body: { textContent: 'Rate limit exceeded' } },
      close: vi.fn(),
    };
    xGhosted.document.defaultView.open.mockReturnValue(mockWindow);
    const promise = xGhosted.checkPostInNewTab('/test/status/123');
    vi.advanceTimersByTime(500);
    expect(xGhosted.state.isRateLimited).toBe(true);
    vi.advanceTimersByTime(xGhosted.timing.rateLimitPause);
    const result = await promise;
    expect(xGhosted.state.isRateLimited).toBe(false);
    expect(result).toBe(false);
    expect(mockWindow.close).toHaveBeenCalled();
  });

  test('saveState and loadState persist data', () => {
    xGhosted.highlightPosts();
    xGhosted.saveState();
    const saved = gmStorage.xGhostedState;
    expect(saved.processedPosts['/OwenGregorian/status/1896977661144260900'].analysis.quality).toBe(postQuality.PROBLEM);
    xGhosted.state.processedPosts.clear();
    xGhosted.loadState();
    expect(xGhosted.state.processedPosts.size).toBeGreaterThan(0);
  });

  test('highlightPosts calls identifyPost once per post', () => {
    // Mock identifyPost to track calls
    const spy = vi.spyOn(identifyPostModule, 'identifyPost');

    // Add data-xghosted attribute to post container
    findPostContainer(document);

    // Check the number of posts
    const posts = document.querySelectorAll('div[data-xghosted="posts-container"] div[data-testid="cellInnerDiv"]');
    expect(posts.length).toBe(36);

    // Run highlightPosts
    xGhosted.highlightPosts();

    // Verify identifyPost was called twice
    expect(spy).toHaveBeenCalledTimes(36);
    expect(spy).toHaveBeenCalledWith(posts[0], true); // Assuming checkReplies is true
    expect(spy).toHaveBeenCalledWith(posts[35], true);
  });

  test('highlightPosts does not call identifyPost after first processing', () => {
    // Mock identifyPost to track calls
    const spy = vi.spyOn(identifyPostModule, 'identifyPost');

    // Add data-xghosted attribute to post container
    findPostContainer(document);

    const selector = 'div[data-xghosted="posts-container"] div[data-testid="cellInnerDiv"]:not([data-xghosted-id])';

    // Check the number of posts
    const posts = document.querySelectorAll(selector);
    expect(posts.length).toBe(36);

    // Run highlightPosts
    xGhosted.highlightPosts();

    // Verify identifyPost was called twice
    expect(spy).toHaveBeenCalledTimes(36);
    expect(spy).toHaveBeenCalledWith(posts[0], true); // Assuming checkReplies is true
    expect(spy).toHaveBeenCalledWith(posts[35], true);

    // Check the number of posts
    const secondPassPosts = document.querySelectorAll(selector);
    expect(secondPassPosts.length).toBe(0);

    // Mock identifyPost to track calls
    const secondPassSpy = vi.spyOn(identifyPostModule, 'identifyPost');

    // Run highlightPosts
    xGhosted.highlightPosts();

    // Verify identifyPost was called twice
    expect(secondPassSpy).toHaveBeenCalledTimes(0);
  });

  test('highlightPost does not call identifyPost on previously processed posts', () => {
    const { PROBLEM } = postQuality;

    // Mock identifyPost to track calls
    const spy = vi.spyOn(identifyPostModule, 'identifyPost');

    // Add data-xghosted attribute to post container
    findPostContainer(document);

    const selector = 'div[data-xghosted="posts-container"] div[data-testid="cellInnerDiv"]:not([data-xghosted-id])';

    // Check the number of posts
    const posts = document.querySelectorAll(selector);
    expect(posts.length).toBe(36);

    // Add previously processedPost which will show up in the new query
    xGhosted.state.processedPosts.set("/OwenGregorian/status/1896977661144260900", {
      analysis: {
        quality: PROBLEM,
        link: "/OwenGregorian/status/1896977661144260900",
        reason: "Found notice: this post is unavailable"
      },
      checked: false
    });

    // Run highlightPosts
    xGhosted.highlightPosts();

    // Verify identifyPost was called twice
    expect(spy).toHaveBeenCalledTimes(35);
    expect(spy).toHaveBeenCalledWith(posts[0], true); // Assuming checkReplies is true
    expect(spy).toHaveBeenCalledWith(posts[35], true);

    // Now we do a second pass and should fine none
    // This proves that the cached post did get processed but not re-identified with postIdentify
    const secondPassPosts = document.querySelectorAll(selector);
    expect(secondPassPosts.length).toBe(0);

    // Mock identifyPost to track calls
    const secondPassSpy = vi.spyOn(identifyPostModule, 'identifyPost');

    // Run highlightPosts
    xGhosted.highlightPosts();

    // Verify identifyPost was called twice
    expect(secondPassSpy).toHaveBeenCalledTimes(0);
  });
});

// File: src/xGhosted.user.js
// --------------------------------
// ==UserScript==
// @name         xGhosted-decoupling
// @namespace    http://tampermonkey.net/
// @version      0.6.1
// @description  Highlight and manage problem posts on X.com with a resizable, draggable panel
// @author       You
// @match        https://x.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=x.com
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_log
// @require      https://unpkg.com/preact@10.26.4/dist/preact.min.js
// @require      https://unpkg.com/preact@10.26.4/hooks/dist/hooks.umd.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js
// @run-at       document-idle
// ==/UserScript==

(function () {
  'use strict';

  // Safety check: Ensure we're on X.com with a valid document
  const log =
    typeof GM_log !== 'undefined' ? GM_log : console.log.bind(console);
  if (!window.location.href.startsWith('https://x.com/') || !document.body) {
    log('xGhosted: Aborting - invalid environment');
    return;
  }

  // Log startup with safety focus
  log(
    'xGhosted v0.6.1 starting - Manual mode on, resource use capped, rate limit pause set to 20 seconds'
  );

  // Check if Preact and Preact Hooks dependencies loaded
  if (!window.preact || !window.preactHooks) {
    log(
      'xGhosted: Aborting - Failed to load dependencies. Preact: ' +
        (window.preact ? 'loaded' : 'missing') +
        ', Preact Hooks: ' +
        (window.preactHooks ? 'loaded' : 'missing')
    );
    return;
  }

  // Check if Font Awesome loaded
  if (typeof window.FontAwesome === 'undefined') {
    log(
      'xGhosted: Font Awesome failed to load, icons may not display correctly'
    );
  }

  // --- Inject Shared Utilities ---
  window.XGhostedUtils = (function () {
    // src/utils/postQuality.js
    var postQuality = Object.freeze({
      UNDEFINED: Object.freeze({ name: 'Undefined', value: 0 }),
      PROBLEM: Object.freeze({ name: 'Problem', value: 1 }),
      POTENTIAL_PROBLEM: Object.freeze({ name: 'Potential Problem', value: 2 }),
      GOOD: Object.freeze({ name: 'Good', value: 3 }),
    });

    // src/dom/detectTheme.js
    function detectTheme(doc) {
      const dataTheme = doc.body.getAttribute('data-theme');
      if (dataTheme) {
        if (dataTheme.includes('lights-out') || dataTheme.includes('dark')) {
          return 'dark';
        } else if (dataTheme.includes('dim')) {
          return 'dim';
        } else if (
          dataTheme.includes('light') ||
          dataTheme.includes('default')
        ) {
          return 'light';
        }
      }
      const bodyClasses = doc.body.classList;
      if (
        bodyClasses.contains('dark') ||
        bodyClasses.contains('theme-dark') ||
        bodyClasses.contains('theme-lights-out')
      ) {
        return 'dark';
      } else if (
        bodyClasses.contains('dim') ||
        bodyClasses.contains('theme-dim')
      ) {
        return 'dim';
      } else if (
        bodyClasses.contains('light') ||
        bodyClasses.contains('theme-light')
      ) {
        return 'light';
      }
      const bodyBgColor = doc.defaultView.getComputedStyle(
        doc.body
      ).backgroundColor;
      if (bodyBgColor === 'rgb(0, 0, 0)') {
        return 'dark';
      } else if (bodyBgColor === 'rgb(21, 32, 43)') {
        return 'dim';
      } else if (bodyBgColor === 'rgb(255, 255, 255)') {
        return 'light';
      }
      return 'light';
    }

    // src/utils/postHasProblemCommunity.js
    function postHasProblemCommunity(article) {
      const communityIds = ['1889908654133911912'];
      const aTags = Array.from(article.querySelectorAll('a'));
      for (const aTag of aTags) {
        for (const id of communityIds) {
          if (aTag.href.endsWith(`/i/communities/${id}`)) {
            return id;
          }
        }
      }
      return false;
    }

    // src/utils/postHasProblemSystemNotice.js
    function postHasProblemSystemNotice(article) {
      const targetNotices = [
        'unavailable',
        'content warning',
        'this post is unavailable',
        'this post violated the x rules',
        'this post was deleted by the post author',
        'this post is from an account that no longer exists',
        "this post may violate x's rules against hateful conduct",
        'this media has been disabled in response to a report by the copyright owner',
        "you're unable to view this post",
      ];
      function normalizedTextContent(textContent) {
        return textContent.replace(/[â€˜â€™]/g, "'").toLowerCase();
      }
      const spans = Array.from(article.querySelectorAll('span'));
      for (const span of spans) {
        const textContent = normalizedTextContent(span.textContent);
        for (const notice of targetNotices) {
          if (textContent.startsWith(notice)) {
            return notice;
          }
        }
      }
      return false;
    }

    // src/utils/findReplyingToWithDepth.js
    function findReplyingToWithDepth(article) {
      function getInnerHTMLWithoutAttributes(element) {
        const clone = element.cloneNode(true);
        clone.querySelectorAll('*').forEach((el) => {
          while (el.attributes.length > 0) {
            el.removeAttribute(el.attributes[0].name);
          }
        });
        return clone.innerHTML;
      }
      function findDivs(element, depth) {
        if (element.tagName === 'DIV') {
          if (element.innerHTML.startsWith('Replying to')) {
            result.push({
              depth,
              innerHTML: getInnerHTMLWithoutAttributes(element).replace(
                /<\/?(div|span)>/gi,
                ''
              ),
            });
          }
        }
        Array.from(element.children).forEach((child) =>
          findDivs(child, depth + 1)
        );
      }
