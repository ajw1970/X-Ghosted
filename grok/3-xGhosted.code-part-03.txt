      const result = [];
      findDivs(article, 0);
      return result;
    }

    // src/utils/getRelativeLinkToPost.js
    function getRelativeLinkToPost(element) {
      const link = element.querySelector('a:has(time)')?.getAttribute('href');
      return link || false;
    }

    // src/utils/identifyPost.js
    function identifyPost(post, checkReplies = true, logger = console.log) {
      const article = post.querySelector('article');
      if (!article) {
        return {
          quality: postQuality.UNDEFINED,
          reason: 'No article found',
          link: false,
        };
      }
      const noticeFound = postHasProblemSystemNotice(article);
      if (noticeFound) {
        return {
          quality: postQuality.PROBLEM,
          reason: `Found notice: ${noticeFound}`,
          link: getRelativeLinkToPost(post),
        };
      }
      const communityFound = postHasProblemCommunity(article);
      if (communityFound) {
        return {
          quality: postQuality.PROBLEM,
          reason: `Found community: ${communityFound}`,
          link: getRelativeLinkToPost(post),
        };
      }
      if (checkReplies) {
        const replyingToDepths = findReplyingToWithDepth(article);
        if (Array.isArray(replyingToDepths) && replyingToDepths.length > 0) {
          const replyingTo = replyingToDepths.find(
            (object) => object.depth < 10
          );
          if (replyingTo) {
            return {
              quality: postQuality.POTENTIAL_PROBLEM,
              reason: `Found: '${replyingTo.innerHTML}' at a depth of ${replyingTo.depth}`,
              link: getRelativeLinkToPost(post),
            };
          } else {
          }
        } else {
        }
      }
      const link = getRelativeLinkToPost(post);
      if (link) {
        return {
          quality: postQuality.GOOD,
          reason: 'Looks good',
          link,
        };
      }
      return {
        quality: postQuality.UNDEFINED,
        reason: 'Nothing to measure',
        link: false,
      };
    }

    // src/utils/debounce.js
    function debounce(func, wait) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        return new Promise((resolve, reject) => {
          timeout = setTimeout(() => {
            try {
              const result = func(...args);
              if (result && typeof result.then === 'function') {
                result.then(resolve).catch(reject);
              } else {
                resolve(result);
              }
            } catch (error) {
              reject(error);
            }
          }, wait);
        });
      };
    }

    // src/dom/findPostContainer.js
    function findPostContainer(doc, log = () => {}) {
      const potentialPosts = doc.querySelectorAll(
        'div[data-testid="cellInnerDiv"]'
      );
      if (!potentialPosts.length) {
        return null;
      }
      let firstPost = null;
      for (const post of potentialPosts) {
        const closestAriaLabel = post.closest('div[aria-label]');
        if (
          closestAriaLabel &&
          closestAriaLabel.getAttribute('aria-label') === 'Timeline: Messages'
        ) {
          log('Skipping post in Messages timeline');
          continue;
        }
        firstPost = post;
        break;
      }
      if (!firstPost) {
        log('No valid posts found outside Messages timeline');
        return null;
      }
      let currentElement = firstPost.parentElement;
      while (currentElement) {
        if (currentElement.hasAttribute('aria-label')) {
          currentElement.setAttribute('data-xghosted', 'posts-container');
          const ariaLabel = currentElement.getAttribute('aria-label');
          log(`Posts container identified with aria-label: "${ariaLabel}"`);
          return currentElement;
        }
        currentElement = currentElement.parentElement;
      }
      log('No parent container found with aria-label');
      return null;
    }

    // src/dom/parseUrl.js
    function parseUrl(url) {
      const reservedPaths = [
        'i',
        'notifications',
        'home',
        'explore',
        'messages',
        'compose',
        'settings',
      ];
      const regex = /^https:\/\/x\.com\/([^/]+)(?:\/(with_replies))?/;
      const match = url.match(regex);
      if (match && !reservedPaths.includes(match[1])) {
        return {
          isWithReplies: !!match[2],
          userProfileName: match[1],
        };
      }
      return {
        isWithReplies: false,
        userProfileName: null,
      };
    }

    // src/utils/clipboardUtils.js
    function copyTextToClipboard(text, log) {
      return navigator.clipboard
        .writeText(text)
        .then(() => log('Text copied to clipboard'))
        .catch((err) => log(`Clipboard copy failed: ${err}`));
    }
    function exportToCSV(data, filename, doc, log) {
      const blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = doc.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      log(`Exported CSV: ${filename}`);
    }
    return {
      copyTextToClipboard,
      debounce,
      detectTheme,
      exportToCSV,
      findPostContainer,
      findReplyingToWithDepth,
      getRelativeLinkToPost,
      identifyPost,
      parseUrl,
      postHasProblemCommunity,
      postHasProblemSystemNotice,
      postQuality,
    };
  })();

  // --- Inject Modules ---
  window.XGhosted = (function () {
    // src/utils/postQuality.js
    var postQuality = Object.freeze({
      UNDEFINED: Object.freeze({ name: 'Undefined', value: 0 }),
      PROBLEM: Object.freeze({ name: 'Problem', value: 1 }),
      POTENTIAL_PROBLEM: Object.freeze({ name: 'Potential Problem', value: 2 }),
      GOOD: Object.freeze({ name: 'Good', value: 3 }),
    });

    // src/dom/detectTheme.js
    function detectTheme(doc) {
      const dataTheme = doc.body.getAttribute('data-theme');
      if (dataTheme) {
        if (dataTheme.includes('lights-out') || dataTheme.includes('dark')) {
          return 'dark';
        } else if (dataTheme.includes('dim')) {
          return 'dim';
        } else if (
          dataTheme.includes('light') ||
          dataTheme.includes('default')
        ) {
          return 'light';
        }
      }
      const bodyClasses = doc.body.classList;
      if (
        bodyClasses.contains('dark') ||
        bodyClasses.contains('theme-dark') ||
        bodyClasses.contains('theme-lights-out')
      ) {
        return 'dark';
      } else if (
        bodyClasses.contains('dim') ||
        bodyClasses.contains('theme-dim')
      ) {
        return 'dim';
      } else if (
        bodyClasses.contains('light') ||
        bodyClasses.contains('theme-light')
      ) {
        return 'light';
      }
      const bodyBgColor = doc.defaultView.getComputedStyle(
        doc.body
      ).backgroundColor;
      if (bodyBgColor === 'rgb(0, 0, 0)') {
        return 'dark';
      } else if (bodyBgColor === 'rgb(21, 32, 43)') {
        return 'dim';
      } else if (bodyBgColor === 'rgb(255, 255, 255)') {
        return 'light';
      }
      return 'light';
    }

    // src/utils/postHasProblemCommunity.js
    function postHasProblemCommunity(article) {
      const communityIds = ['1889908654133911912'];
      const aTags = Array.from(article.querySelectorAll('a'));
      for (const aTag of aTags) {
        for (const id of communityIds) {
          if (aTag.href.endsWith(`/i/communities/${id}`)) {
            return id;
          }
        }
      }
      return false;
    }

    // src/utils/postHasProblemSystemNotice.js
    function postHasProblemSystemNotice(article) {
      const targetNotices = [
        'unavailable',
        'content warning',
        'this post is unavailable',
        'this post violated the x rules',
        'this post was deleted by the post author',
        'this post is from an account that no longer exists',
        "this post may violate x's rules against hateful conduct",
        'this media has been disabled in response to a report by the copyright owner',
        "you're unable to view this post",
      ];
      function normalizedTextContent(textContent) {
        return textContent.replace(/[‘’]/g, "'").toLowerCase();
      }
      const spans = Array.from(article.querySelectorAll('span'));
      for (const span of spans) {
        const textContent = normalizedTextContent(span.textContent);
        for (const notice of targetNotices) {
          if (textContent.startsWith(notice)) {
            return notice;
          }
        }
      }
      return false;
    }

    // src/utils/findReplyingToWithDepth.js
    function findReplyingToWithDepth(article) {
      function getInnerHTMLWithoutAttributes(element) {
        const clone = element.cloneNode(true);
        clone.querySelectorAll('*').forEach((el) => {
          while (el.attributes.length > 0) {
            el.removeAttribute(el.attributes[0].name);
          }
        });
        return clone.innerHTML;
      }
      function findDivs(element, depth) {
        if (element.tagName === 'DIV') {
          if (element.innerHTML.startsWith('Replying to')) {
            result.push({
              depth,
              innerHTML: getInnerHTMLWithoutAttributes(element).replace(
                /<\/?(div|span)>/gi,
                ''
              ),
            });
          }
        }
        Array.from(element.children).forEach((child) =>
          findDivs(child, depth + 1)
        );
      }
      const result = [];
      findDivs(article, 0);
      return result;
    }

    // src/utils/getRelativeLinkToPost.js
    function getRelativeLinkToPost(element) {
      const link = element.querySelector('a:has(time)')?.getAttribute('href');
      return link || false;
    }

    // src/utils/identifyPost.js
    function identifyPost(post, checkReplies = true, logger = console.log) {
      const article = post.querySelector('article');
      if (!article) {
        return {
          quality: postQuality.UNDEFINED,
          reason: 'No article found',
          link: false,
        };
      }
      const noticeFound = postHasProblemSystemNotice(article);
      if (noticeFound) {
        return {
          quality: postQuality.PROBLEM,
          reason: `Found notice: ${noticeFound}`,
          link: getRelativeLinkToPost(post),
        };
      }
      const communityFound = postHasProblemCommunity(article);
      if (communityFound) {
        return {
          quality: postQuality.PROBLEM,
          reason: `Found community: ${communityFound}`,
          link: getRelativeLinkToPost(post),
        };
      }
      if (checkReplies) {
        const replyingToDepths = findReplyingToWithDepth(article);
        if (Array.isArray(replyingToDepths) && replyingToDepths.length > 0) {
          const replyingTo = replyingToDepths.find(
            (object) => object.depth < 10
          );
          if (replyingTo) {
            return {
              quality: postQuality.POTENTIAL_PROBLEM,
              reason: `Found: '${replyingTo.innerHTML}' at a depth of ${replyingTo.depth}`,
              link: getRelativeLinkToPost(post),
            };
          } else {
          }
        } else {
        }
      }
      const link = getRelativeLinkToPost(post);
      if (link) {
        return {
          quality: postQuality.GOOD,
          reason: 'Looks good',
          link,
        };
      }
      return {
        quality: postQuality.UNDEFINED,
        reason: 'Nothing to measure',
        link: false,
      };
    }

    // src/utils/debounce.js
    function debounce(func, wait) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        return new Promise((resolve, reject) => {
          timeout = setTimeout(() => {
            try {
              const result = func(...args);
              if (result && typeof result.then === 'function') {
                result.then(resolve).catch(reject);
              } else {
                resolve(result);
              }
            } catch (error) {
              reject(error);
            }
          }, wait);
        });
      };
    }

    // src/dom/findPostContainer.js
    function findPostContainer(doc, log = () => {}) {
      const potentialPosts = doc.querySelectorAll(
        'div[data-testid="cellInnerDiv"]'
      );
      if (!potentialPosts.length) {
        return null;
      }
      let firstPost = null;
      for (const post of potentialPosts) {
        const closestAriaLabel = post.closest('div[aria-label]');
        if (
          closestAriaLabel &&
          closestAriaLabel.getAttribute('aria-label') === 'Timeline: Messages'
        ) {
          log('Skipping post in Messages timeline');
          continue;
        }
        firstPost = post;
        break;
      }
      if (!firstPost) {
        log('No valid posts found outside Messages timeline');
        return null;
      }
      let currentElement = firstPost.parentElement;
      while (currentElement) {
        if (currentElement.hasAttribute('aria-label')) {
          currentElement.setAttribute('data-xghosted', 'posts-container');
          const ariaLabel = currentElement.getAttribute('aria-label');
          log(`Posts container identified with aria-label: "${ariaLabel}"`);
          return currentElement;
        }
        currentElement = currentElement.parentElement;
      }
      log('No parent container found with aria-label');
      return null;
    }

    // src/dom/parseUrl.js
    function parseUrl(url) {
      const reservedPaths = [
        'i',
        'notifications',
        'home',
        'explore',
        'messages',
        'compose',
        'settings',
      ];
      const regex = /^https:\/\/x\.com\/([^/]+)(?:\/(with_replies))?/;
      const match = url.match(regex);
      if (match && !reservedPaths.includes(match[1])) {
        return {
          isWithReplies: !!match[2],
          userProfileName: match[1],
        };
      }
      return {
        isWithReplies: false,
        userProfileName: null,
      };
    }

    // src/xGhosted.js
    function XGhosted(doc, config = {}) {
      const defaultTiming = {
        debounceDelay: 500,
        throttleDelay: 1e3,
        tabCheckThrottle: 5e3,
        exportThrottle: 5e3,
        pollInterval: 1e3,
        scrollInterval: 1500,
      };
      this.timing = { ...defaultTiming, ...config.timing };
      this.document = doc;
      this.log = config.log || console.log.bind(console);
      if (!config.postsManager) {
        throw new Error('XGhosted requires a postsManager instance');
      }
      this.postsManager = config.postsManager;
      this.state = {
        postContainer: null,
        lastUrlFullPath: '',
        isWithReplies: false,
        isRateLimited: false,
        isAutoScrollingEnabled: false,
        isHighlighting: false,
        isPollingEnabled: true,
        userProfileName: null,
      };
      this.checkPostInNewTabThrottled = debounce((href) => {
        return this.checkPostInNewTab(href);
      }, this.timing.tabCheckThrottle);
      this.highlightPostsDebounced = debounce(() => {
        this.highlightPosts();
      }, this.timing.debounceDelay);
    }
    XGhosted.POST_CONTAINER_SELECTOR = 'div[data-xghosted="posts-container"]';
    XGhosted.UNPROCESSED_POSTS_SELECTOR = `${XGhosted.POST_CONTAINER_SELECTOR} div[data-testid="cellInnerDiv"]:not([data-xghosted-id])`;
    XGhosted.prototype.getUrlFullPathIfChanged = function (url) {
      const urlParts = new URL(url);
      const urlFullPath = urlParts.origin + urlParts.pathname;
      if (this.state.lastUrlFullPath === urlFullPath) {
        return false;
      }
      this.log(
        `URL has changed from (${this.state.lastUrlFullPath}) to (${urlFullPath})`
      );
      this.state.lastUrlFullPath = urlFullPath;
      return urlFullPath;
    };
    XGhosted.prototype.handleUrlChange = function (urlFullPath) {
      const { isWithReplies, userProfileName } = parseUrl(urlFullPath);
      this.state.isWithReplies = isWithReplies;
      if (this.state.userProfileName !== userProfileName) {
        this.state.userProfileName = userProfileName;
        this.document.dispatchEvent(
          new CustomEvent('xghosted:user-profile-updated', {
            detail: {
              userProfileName: this.state.userProfileName,
            },
          })
        );
      }
      this.postsManager.clearPosts();
    };
    XGhosted.prototype.checkPostInNewTab = function (href) {
      this.log(`Checking post in new tab: ${href}`);
      const fullUrl = `${this.postsManager.linkPrefix}${href}`;
      const newWindow = this.document.defaultView.open(fullUrl, '_blank');
      let attempts = 0;
      const maxAttempts = 10;
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          attempts++;
          if (newWindow && newWindow.document.readyState === 'complete') {
            const doc = newWindow.document;
            if (doc.body.textContent.includes('Rate limit exceeded')) {
              clearInterval(checkInterval);
              this.log('Rate limit detected, pausing operations');
              this.state.isRateLimited = true;
              newWindow.close();
              setTimeout(() => {
                this.log('Resuming after rate limit pause');
                this.state.isRateLimited = false;
                resolve(false);
              }, this.timing.rateLimitPause);
              return;
            }
            const targetPost = doc.querySelector(
              `[data-xghosted-id="${href}"]`
            );
            if (targetPost) {
              this.log(`Original post found in new tab: ${href}`);
              clearInterval(checkInterval);
              const hasProblem =
                doc.querySelector('[data-xghosted="postquality.problem"]') !==
                null;
              if (hasProblem) {
                newWindow.scrollTo(0, 0);
                this.log(`Problem found in thread at ${href}`);
              } else {
                newWindow.close();
                this.log(`No problem found in thread at ${href}`);
              }
              resolve(hasProblem);
            }
          }
          if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            if (newWindow) newWindow.close();
            this.log(
              `Failed to process ${href} within ${maxAttempts} attempts`
            );
            resolve(false);
          }
        }, 500);
      });
    };
    XGhosted.prototype.userRequestedPostCheck = function (href, post) {
      this.log(`User requested check for ${href}`);
      const cached = this.postsManager.getPost(href);
      if (
        !cached ||
        cached.analysis.quality.name !== postQuality.POTENTIAL_PROBLEM.name
      ) {
        this.log(`Manual check skipped for ${href}: not a potential problem`);
        return;
      }
      if (!cached.checked) {
        this.handleStopPolling();
        this.log(`Manual check starting for ${href}`);
        this.checkPostInNewTab(href).then((isProblem) => {
          this.log(
            `Manual check result for ${href}: ${isProblem ? 'problem' : 'good'}`
          );
          const currentPost = this.document.querySelector(
            `[data-xghosted-id="${href}"]`
          );
          if (!currentPost) {
            this.log(
              `Post with href ${href} no longer exists in the DOM, skipping DOM update`
            );
          } else {
            currentPost.classList.remove(
              'xghosted-potential_problem',
              'xghosted-good',
              'xghosted-problem'
            );
            currentPost.classList.add(
              isProblem ? 'xghosted-problem' : 'xghosted-good'
            );
            currentPost.setAttribute(
              'data-xghosted',
              `postquality.${isProblem ? 'problem' : 'good'}`
            );
            const eyeballContainer =
              currentPost.querySelector('.xghosted-eyeball');
            if (eyeballContainer) {
              eyeballContainer.classList.remove('xghosted-eyeball');
            } else {
              this.log(
                `Eyeball container not found for post with href: ${href}`
              );
            }
          }
          cached.analysis.quality = isProblem
            ? postQuality.PROBLEM
            : postQuality.GOOD;
          cached.checked = true;
          this.postsManager.registerPost(href, cached);
          this.document.dispatchEvent(
            new CustomEvent('xghosted:state-updated', {
              detail: { ...this.state },
            })
          );
          this.log(`User requested post check completed for ${href}`);
        });
      } else {
        this.log(`Manual check skipped for ${href}: already checked`);
      }
    };
    XGhosted.prototype.handleStartPolling = function () {
      this.state.isPollingEnabled = true;
      this.startPolling();
      this.startAutoScrolling();
      this.document.dispatchEvent(
        new CustomEvent('xghosted:polling-state-updated', {
          detail: { isPollingEnabled: this.state.isPollingEnabled },
        })
      );
    };
    XGhosted.prototype.handleStopPolling = function () {
      this.state.isPollingEnabled = false;
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
      if (this.scrollTimer) {
        clearInterval(this.scrollTimer);
        this.scrollTimer = null;
      }
      this.document.dispatchEvent(
        new CustomEvent('xghosted:polling-state-updated', {
          detail: { isPollingEnabled: this.state.isPollingEnabled },
        })
      );
    };
    XGhosted.prototype.startPolling = function () {
      if (!this.state.isPollingEnabled) {
        this.log('Polling not started: polling is disabled');
        return;
      }
      const pollInterval = this.timing.pollInterval || 1e3;
      this.log('Starting polling for post changes...');
      this.pollTimer = setInterval(() => {
        if (this.state.isHighlighting) {
          this.log('Polling skipped\u2014highlighting in progress');
          return;
        }
        const urlFullPath = this.getUrlFullPathIfChanged(
          this.document.location.href
        );
        if (urlFullPath) {
          this.log(
            `URL has changed from (${this.state.lastUrlFullPath}) to (${urlFullPath})`
          );
          this.handleUrlChange(urlFullPath);
        }
        const unprocessedPosts = this.document.querySelectorAll(
          XGhosted.UNPROCESSED_POSTS_SELECTOR
        );
        if (unprocessedPosts.length > 0) {
          this.highlightPosts(unprocessedPosts);
        } else if (
          !this.document.querySelector(XGhosted.POST_CONTAINER_SELECTOR)
        ) {
          this.log('No post container found, trying to find it...');
          const foundContainer = findPostContainer(this.document, this.log);
          if (foundContainer) {
            this.highlightPosts();
          } else {
            this.log('Container still not found, skipping highlighting');
          }
        } else {
        }
      }, pollInterval);
    };
    XGhosted.prototype.startAutoScrolling = function () {
      if (!this.state.isPollingEnabled) {
        this.log('Auto-scrolling not started: polling is disabled');
        return;
      }
      const scrollInterval = this.timing.scrollInterval || 3e3;
      this.log('Starting auto-scrolling timer...');
      this.scrollTimer = setInterval(() => {
        if (!this.state.isPollingEnabled) {
          this.log('Auto-scrolling skipped\u2014polling is disabled');
          return;
        }
        if (this.state.isAutoScrollingEnabled) {
          const scrollHeight = this.document.documentElement.scrollHeight;
          const scrollTop = window.scrollY + window.innerHeight;
          if (scrollTop >= scrollHeight - 10) {
            this.log('Reached page bottom, stopping auto-scrolling');
            this.toggleAutoScrolling();
            return;
          }
          window.scrollBy({
            top: window.innerHeight * 0.8,
            behavior: 'smooth',
          });
        }
      }, scrollInterval);
    };
    XGhosted.prototype.toggleAutoScrolling = function () {
      this.state.isAutoScrollingEnabled = !this.state.isAutoScrollingEnabled;
      this.document.dispatchEvent(
        new CustomEvent('xghosted:auto-scrolling-toggled', {
          detail: { isAutoScrollingEnabled: this.state.isAutoScrollingEnabled },
        })
      );
    };
    XGhosted.prototype.expandArticle = function (article) {
      if (article) {
        article.style.height = 'auto';
        article.style.overflow = 'visible';
        article.style.margin = 'auto';
        article.style.padding = 'auto';
      }
    };
    XGhosted.prototype.highlightPosts = function (posts) {
      this.state.isHighlighting = true;
      const processPostAnalysis = (post, analysis) => {
        if (!(post instanceof this.document.defaultView.Element)) {
          this.log('Skipping invalid DOM element:', post);
          return;
        }
        const id = analysis.link;
        const qualityName = analysis.quality.name
          .toLowerCase()
          .replace(' ', '_');
        post.setAttribute('data-xghosted-id', id);
        post.setAttribute('data-xghosted', `postquality.${qualityName}`);
        post.classList.add(`xghosted-${qualityName}`);
        if (analysis.quality === postQuality.POTENTIAL_PROBLEM) {
          const shareButtonContainer = post.querySelector(
            'button[aria-label="Share post"]'
          )?.parentElement;
          if (shareButtonContainer) {
            shareButtonContainer.classList.add('xghosted-eyeball');
          } else {
            this.log(
              `No share button container found for post with href: ${id}`
            );
          }
        }
        if (id) {
          this.postsManager.registerPost(id, { analysis, checked: false });
        }
      };
      const checkReplies = this.state.isWithReplies;
      const userProfileName = this.state.userProfileName;
      const results = [];
      const postsToProcess =
        posts ||
        this.document.querySelectorAll(XGhosted.UNPROCESSED_POSTS_SELECTOR);
      let postsProcessed = 0;
      let cachedAnalysis = false;
      postsToProcess.forEach((post) => {
        const postId = getRelativeLinkToPost(post);
        if (postId) {
          const cachedPost = this.postsManager.getPost(postId);
          cachedAnalysis = cachedPost?.analysis;
        }
        let analysis = cachedAnalysis
          ? { ...cachedAnalysis }
          : identifyPost(post, checkReplies);
        if (analysis?.quality === postQuality.PROBLEM) {
          this.handleStopPolling();
        }
        if (!cachedAnalysis) postsProcessed++;
        processPostAnalysis(post, analysis);
        results.push(analysis);
      });
      if (postsProcessed > 0) {
        this.document.dispatchEvent(
          new CustomEvent('xghosted:state-updated', {
            detail: { ...this.state },
          })
        );
        this.log(
          `Highlighted ${postsProcessed} new posts, state-updated emitted`
        );
      }
      this.state.isHighlighting = false;
      return results;
    };
    XGhosted.prototype.getThemeMode = function () {
      return detectTheme(this.document);
    };
    XGhosted.prototype.init = function () {
      this.log('Initializing XGhosted...');
      if (this.document.body) {
        const themeMode = this.getThemeMode();
        this.document.dispatchEvent(
          new CustomEvent('xghosted:theme-detected', {
            detail: { themeMode },
          })
        );
      } else {
        this.log('Document body not available for theme detection');
      }
      this.document.dispatchEvent(
        new CustomEvent('xghosted:init', {
          detail: {
            config: {
              pollInterval: this.timing.pollInterval,
              scrollInterval: this.timing.scrollInterval,
            },
          },
        })
      );
      const styleSheet = this.document.createElement('style');
      styleSheet.textContent = `
    .xghosted-good { border: 2px solid green; background: rgba(0, 255, 0, 0.1); }
    .xghosted-problem { border: 2px solid red; background: rgba(255, 0, 0, 0.1); }
    .xghosted-undefined { border: 2px solid gray; background: rgba(128, 128, 128, 0.1); }
    .xghosted-potential_problem { border: 2px solid yellow; background: rgba(255, 255, 0, 0.1); }
    .xghosted-collapsed { height: 0px; overflow: hidden; margin: 0; padding: 0; }
    .xghosted-eyeball::after {
      content: '\u{1F440}';
      color: rgb(29, 155, 240);
      padding: 8px;
      cursor: pointer;
      text-decoration: none;
    }
  `;
      this.document.head.appendChild(styleSheet);
      this.document.addEventListener(
        'click',
        (e) => {
          const eyeball =
            e.target.closest('.xghosted-eyeball') ||
            (e.target.classList.contains('xghosted-eyeball') ? e.target : null);
          if (eyeball) {
            e.preventDefault();
            e.stopPropagation();
            this.log('Eyeball clicked! Digging in...');
            const clickedPost = eyeball.closest('div[data-xghosted-id]');
            const href = clickedPost?.getAttribute('data-xghosted-id');
            if (!href) {
              this.log('No href found for clicked eyeball');
              return;
            }
            this.log(`Processing eyeball click for: ${href}`);
            if (this.state.isRateLimited) {
              this.log(`Eyeball click skipped for ${href} due to rate limit`);
              return;
            }
            const cached = this.postsManager.getPost(href);
            this.userRequestedPostCheck(href, clickedPost);
          }
        },
        { capture: true }
      );
      this.startPolling();
      this.startAutoScrolling();
    };
    window.XGhosted = XGhosted;
    return XGhosted;
  })();
  window.SplashPanel = (function () {
    // src/ui/SplashPanel.js
    function SplashPanel(doc, logger, version) {
      this.document = doc;
      this.logger = logger;
      this.container = null;
      this.userProfileName = null;
      this.config = {};
      this.init = function () {
        this.logger('Initializing SplashPanel...');
        this.container = this.document.createElement('div');
        this.container.id = 'xghosted-splash';
        this.container.style.cssText =
          'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; border: 2px solid #333; border-radius: 12px; padding: 20px; z-index: 10000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);';
        this.document.body.appendChild(this.container);
        this.render({
          pollInterval: 'Unknown',
          scrollInterval: 'Unknown',
        });
        this.document.addEventListener(
          'xghosted:init',
          (e) => {
            this.config = e.detail?.config || {};
            this.logger('Received xghosted:init with config:', this.config);
            this.render({
              pollInterval: this.config.pollInterval || 'Unknown',
              scrollInterval: this.config.scrollInterval || 'Unknown',
            });
          },
          { once: true }
        );
        this.document.addEventListener('xghosted:user-profile-updated', (e) => {
          const { userProfileName } = e.detail || {};
          this.logger(
            'Received xghosted:user-profile-updated with userProfileName:',
            userProfileName
          );
          this.userProfileName = userProfileName;
          this.render({
            pollInterval: this.config.pollInterval || 'Unknown',
            scrollInterval: this.config.scrollInterval || 'Unknown',
          });
        });
      };
      this.render = function (config) {
        this.container.innerHTML = `
          <h2 style="margin: 0 0 10px 0; font-size: 24px; color: #333; display: block;">Welcome to xGhosted!</h2>
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Tampermonkey Version: ${version}</p>
          ${this.userProfileName ? `<p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Profile: ${this.userProfileName}</p>` : ''}
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Poll Interval: ${config.pollInterval} ms</p>
          <p style="margin: 5px 0; font-size: 16px; color: #333; display: block;">Scroll Interval: ${config.scrollInterval} ms</p>
          <button style="padding: 8px 16px; background: #3A4A5B; color: #fff; border: 2px solid #8292A2; border-radius: 8px; cursor: pointer; font-size: 14px; display: inline-block;">Close</button>
      `;
        const closeButton = this.container.querySelector('button');
        closeButton.addEventListener('click', () => {
          this.logger('SplashPanel closed');
          this.container.remove();
        });
      };
      try {
        this.init();
      } catch (error) {
        this.logger(`SplashPanel failed to initialize: ${error.message}`);
      }
    }
    return SplashPanel;
  })();
  window.PanelManager = (function () {
    // src/ui/Panel.jsx
    function Panel({
      state,
      config,
      currentMode,
      xGhosted,
      toggleThemeMode,
      onStartPolling,
      onStopPolling,
      onEyeballClick,
      onCopyLinks,
      setPanelPosition,
    }) {
      const flagged = window.preactHooks.useMemo(
        () => xGhosted.postsManager.getProblemPosts(),
        [xGhosted.postsManager.getAllPosts()]
      );
      const totalPosts = xGhosted.postsManager.getAllPosts().length;
      const [isVisible, setIsVisible] = window.preactHooks.useState(
        state.isPanelVisible
      );
      const [isToolsExpanded, setIsToolsExpanded] =
        window.preactHooks.useState(false);
      const [isModalOpen, setIsModalOpen] = window.preactHooks.useState(false);
      const [isDropdownOpen, setIsDropdownOpen] =
        window.preactHooks.useState(false);
      const [isPolling, setIsPolling] = window.preactHooks.useState(
        state.isPollingEnabled
      );
      const [isScrolling, setIsScrolling] = window.preactHooks.useState(
        state.isAutoScrollingEnabled
      );
      window.preactHooks.useEffect(() => {
        setIsPolling(state.isPollingEnabled);
        setIsScrolling(state.isAutoScrollingEnabled);
      }, [state.isPollingEnabled, state.isAutoScrollingEnabled]);
      window.preactHooks.useEffect(() => {
        const handleCsvImport = (e) => {
          if (e.detail.importedCount > 0) {
            setIsModalOpen(false);
          }
        };
        document.addEventListener('xghosted:csv-import', handleCsvImport);
        return () =>
          document.removeEventListener('xghosted:csv-import', handleCsvImport);
      }, []);
      const toggleVisibility = () => {
        const newVisibility = !isVisible;
        setIsVisible(newVisibility);
        xGhosted.togglePanelVisibility(newVisibility);
      };
      const handleDragStart = (e) => {
        const draggedContainer = e.target.closest('#xghosted-panel-container');
        if (!draggedContainer) return;
        draggedContainer.classList.add('dragging');
        const computedStyle = window.getComputedStyle(draggedContainer);
        let currentRight =
          parseFloat(computedStyle.right) ||
          parseFloat(state.panelPosition.right) ||
          10;
        let currentTop =
          parseFloat(computedStyle.top) ||
          parseFloat(state.panelPosition.top) ||
          60;
        let initialX = e.clientX + currentRight;
        let initialY = e.clientY - currentTop;
        let right = currentRight;
        let top = currentTop;
        let lastUpdate = 0;
        const throttleDelay = 16;
        const onMouseMove = (e2) => {
          const now = Date.now();
          if (now - lastUpdate < throttleDelay) return;
          lastUpdate = now;
          right = initialX - e2.clientX;
          top = e2.clientY - initialY;
          right = Math.max(
            0,
            Math.min(right, window.innerWidth - draggedContainer.offsetWidth)
          );
          top = Math.max(
            0,
            Math.min(top, window.innerHeight - draggedContainer.offsetHeight)
          );
          draggedContainer.style.right = `${right}px`;
          draggedContainer.style.top = `${top}px`;
        };
        const onMouseUp = () => {
          try {
            draggedContainer.classList.remove('dragging');
            if (setPanelPosition) {
              setPanelPosition({
                right: `${right}px`,
                top: `${top}px`,
              });
            }
          } catch (error) {
            console.error('Error in onMouseUp:', error);
          } finally {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      };
      const themeOptions = ['dark', 'dim', 'light'].filter(
        (option) => option !== currentMode
      );
      return window.preact.h(
        'div',
        null,
        window.preact.h(
          'div',
          {
            id: 'xghosted-panel',
            style: {
              background: config.THEMES[currentMode].bg,
              border: `2px solid ${isPolling ? config.THEMES[currentMode].border : '#FFA500'}`,
              borderRadius: '12px',
              boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
              color: config.THEMES[currentMode].text,
              cursor: 'move',
              fontFamily: config.PANEL.FONT,
              maxHeight: isVisible ? config.PANEL.MAX_HEIGHT : '48px',
              minWidth: isVisible ? '250px' : '60px',
              padding: isVisible ? '8px 8px 12px 8px' : '4px',
              transition: 'width 0.2s ease, max-height 0.2s ease',
              width: isVisible ? config.PANEL.WIDTH : 'auto',
            },
            onMouseDown: handleDragStart,
          },
          isVisible
            ? window.preact.h(
                window.preact.Fragment,
                null,
                window.preact.h(
                  'div',
                  { className: 'toolbar' },
                  window.preact.h(
                    'button',
                    {
                      key: isToolsExpanded
                        ? 'tools-expanded'
                        : 'tools-collapsed',
                      className: 'panel-button',
                      onClick: () => setIsToolsExpanded(!isToolsExpanded),
                      'aria-label': 'Toggle Tools Section',
                    },
                    window.preact.h('i', {
                      className: isToolsExpanded
                        ? 'fas fa-chevron-up'
                        : 'fas fa-chevron-down',
                      style: { marginRight: '12px' },
                    }),
                    'Tools'
                  ),
                  window.preact.h(
                    'div',
                    {
                      style: {
                        alignItems: 'center',
                        display: 'flex',
                        flex: 1,
                        justifyContent: 'space-between',
                      },
                    },
                    window.preact.h(
                      'button',
                      {
                        key: isPolling ? 'polling-stop' : 'polling-start',
                        className: `panel-button ${isPolling ? '' : 'polling-stopped'}`,
                        onClick: isPolling ? onStopPolling : onStartPolling,
                        'aria-label': isPolling
                          ? 'Stop Polling'
                          : 'Start Polling',
                      },
                      window.preact.h('i', {
                        className: isPolling
                          ? 'fa-solid fa-stop'
                          : 'fa-solid fa-play',
                        style: { marginRight: '12px' },
                      }),
                      'Polling'
                    ),
                    window.preact.h(
                      'button',
                      {
                        key: isScrolling ? 'scroll-stop' : 'scroll-start',
                        className: 'panel-button',
                        onClick: () => xGhosted.toggleAutoScrolling(),
                        'aria-label': isScrolling
                          ? 'Stop Auto-Scroll'
                          : 'Start Auto-Scroll',
                      },
                      window.preact.h('i', {
                        className: isScrolling
                          ? 'fa-solid fa-stop'
                          : 'fa-solid fa-play',
                        style: { marginRight: '12px' },
                      }),
                      'Scroll'
                    ),
                    window.preact.h(
                      'button',
                      {
                        className: 'panel-button',
                        onClick: toggleVisibility,
                        'aria-label': 'Hide Panel',
                      },
                      window.preact.h('i', {
                        className: 'fas fa-eye-slash',
                        style: { marginRight: '12px' },
                      }),
                      'Hide'
                    )
                  )
                ),
                window.preact.h(
                  'div',
                  {
                    className: 'tools-section',
                    style: {
                      background: config.THEMES[currentMode].bg,
                      borderBottom: `1px solid ${config.THEMES[currentMode].border}`,
                      borderRadius: '8px',
                      boxShadow: '0 3px 8px rgba(0, 0, 0, 0.15)',
                      display: isToolsExpanded ? 'block' : 'none',
                      marginBottom: '8px',
                      padding: '12px',
                    },
                  },
                  window.preact.h(
                    'div',
                    {
                      style: {
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '12px',
                        padding: '15px',
                      },
                    },
                    window.preact.h(
                      'div',
                      {
                        style: {
                          borderBottom: '1px solid var(--border-color)',
                          paddingBottom: '12px',
                        },
                      },
                      window.preact.h(
                        'div',
                        { className: 'custom-dropdown' },
                        window.preact.h(
                          'button',
                          {
                            className: 'panel-button dropdown-button',
                            onClick: () => setIsDropdownOpen(!isDropdownOpen),
                            'aria-expanded': isDropdownOpen,
                            'aria-label': 'Select Theme',
                          },
                          currentMode.charAt(0).toUpperCase() +
                            currentMode.slice(1),
                          window.preact.h('i', {
                            className: isDropdownOpen
                              ? 'fas fa-chevron-up'
                              : 'fas fa-chevron-down',
                            style: { marginLeft: '8px' },
                          })
                        ),
                        isDropdownOpen &&
                          window.preact.h(
                            'div',
                            { className: 'dropdown-menu' },
                            themeOptions.map((option) =>
                              window.preact.h(
                                'div',
                                {
                                  key: option,
                                  className: 'dropdown-item',
                                  onClick: () => {
                                    toggleThemeMode(option);
                                    setIsDropdownOpen(false);
                                  },
                                  role: 'option',
                                  'aria-selected': currentMode === option,
                                },
                                option.charAt(0).toUpperCase() + option.slice(1)
                              )
                            )
                          )
                      )
                    ),
                    window.preact.h(
                      'div',
                      {
                        style: {
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '12px',
                          marginBottom: '8px',
                        },
                      },
                      window.preact.h(
                        'button',
                        {
                          className: 'panel-button',
                          onClick: () => {
                            document.dispatchEvent(
                              new CustomEvent('xghosted:copy-links')
                            );
                          },
                          'aria-label': 'Copy Problem Links',
                        },
                        window.preact.h('i', {
                          className: 'fas fa-copy',
                          style: { marginRight: '8px' },
                        }),
                        'Copy'
                      ),
                      window.preact.h(
                        'button',
                        {
                          className: 'panel-button',
                          onClick: () => {
                            document.dispatchEvent(
                              new CustomEvent('xghosted:export-csv')
                            );
                          },
                          'aria-label': 'Export Posts to CSV',
                        },
                        window.preact.h('i', {
                          className: 'fas fa-file-export',
                          style: { marginRight: '8px' },
                        }),
                        'Export CSV'
                      ),
                      window.preact.h(
                        'button',
                        {
                          className: 'panel-button',
                          onClick: () => setIsModalOpen(true),
                          'aria-label': 'Import Posts from CSV',
                        },
                        window.preact.h('i', {
                          className: 'fas fa-file-import',
                          style: { marginRight: '8px' },
                        }),
                        'Import CSV'
                      ),
                      window.preact.h(
                        'button',
                        {
                          className: 'panel-button',
                          onClick: () => {
                            document.dispatchEvent(
                              new CustomEvent('xghosted:clear-posts')
                            );
                          },
                          'aria-label': 'Clear Processed Posts',
                        },
                        window.preact.h('i', {
                          className: 'fas fa-trash',
                          style: { marginRight: '8px' },
                        }),
                        'Clear'
                      )
                    )
                  )
                ),
                window.preact.h(
                  'div',
                  { className: 'content-wrapper' },
                  window.preact.h(
                    'div',
                    { className: 'problem-posts-header' },
                    'Processed Posts (',
                    totalPosts,
                    ') Concerns (',
                    flagged.length,
                    '):',
                    window.preact.h(
                      'span',
                      {
                        style: {
                          cursor: 'pointer',
                          fontSize: '14px',
                          marginLeft: '8px',
                          verticalAlign: 'middle',
                        },
                        onClick: onCopyLinks,
                        'aria-label': 'Copy Concerns to Clipboard',
                        title: 'Copy Concerns to Clipboard',
                      },
                      window.preact.h('i', { className: 'fas fa-copy' })
                    )
                  ),
                  window.preact.h(
                    'div',
                    { className: 'problem-links-wrapper' },
                    flagged.map(([href, { analysis, checked }]) =>
                      window.preact.h(
                        'div',
                        {
                          className: 'link-row',
                          style: { padding: '4px 0' },
                          key: href,
                        },
                        analysis.quality.name === 'Problem'
                          ? window.preact.h('span', {
                              className: 'status-dot status-problem',
                            })
                          : window.preact.h(
                              'span',
                              {
                                className: 'status-eyeball',
                                tabIndex: 0,
                                role: 'button',
                                'aria-label': 'Check post manually',
                                onClick: () => !checked && onEyeballClick(href),
                                onKeyDown: (e) =>
                                  e.key === 'Enter' &&
                                  !checked &&
                                  onEyeballClick(href),
                              },
                              '\u{1F440}'
                            ),
                        window.preact.h(
                          'div',
                          { className: 'link-item' },
                          window.preact.h(
                            'a',
                            {
                              href: `${xGhosted.postsManager.linkPrefix}${href}`,
                              target: '_blank',
                            },
                            href
                          )
                        )
                      )
                    )
                  )
                )
              )
            : window.preact.h(
                'div',
                {
                  style: {
                    display: 'flex',
                    justifyContent: 'flex-end',
                    padding: '0',
                    margin: '0',
                  },
                },
                window.preact.h(
                  'button',
                  {
                    className: 'panel-button',
                    onClick: toggleVisibility,
                    'aria-label': 'Show Panel',
                  },
                  window.preact.h('i', {
                    className: 'fas fa-eye',
                    style: { marginRight: '6px' },
                  }),
                  'Show'
                )
              )
        ),
        isModalOpen &&
          window.preact.h(window.Modal, {
            isOpen: isModalOpen,
            onClose: () => setIsModalOpen(false),
            onSubmit: (csvText) => {
              document.dispatchEvent(
                new CustomEvent('xghosted:csv-import', {
                  detail: { csvText },
                })
              );
            },
            mode: currentMode,
            config,
          })
      );
    }
    window.Panel = Panel;

    // src/ui/PanelManager.js
    function Modal({ isOpen, onClose, onSubmit, mode, config }) {
      const [csvText, setCsvText] = window.preactHooks.useState('');
      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (!file.name.endsWith('.csv')) {
          alert('Please select a CSV file.');
          e.target.value = '';
          return;
        }
        const reader = new FileReader();
        reader.onload = (event) => {
          const text = event.target.result;
          setCsvText(text);
        };
        reader.onerror = () => {
          alert('Error reading the file.');
          e.target.value = '';
        };
        reader.readAsText(file);
      };
      return window.preact.h(
        'div',
        null,
        window.preact.h(
          'div',
          {
            className: 'modal',
            style: {
              display: isOpen ? 'block' : 'none',
              '--modal-bg': config.THEMES[mode].bg,
              '--modal-text': config.THEMES[mode].text,
              '--modal-button-bg': config.THEMES[mode].button,
              '--modal-button-text': config.THEMES[mode].buttonText,
              '--modal-hover-bg': config.THEMES[mode].hover,
              '--modal-border': config.THEMES[mode].border,
            },
          },
          window.preact.h(
            'div',
            { className: 'modal-file-input-container' },
            window.preact.h('input', {
              type: 'file',
              className: 'modal-file-input',
              accept: '.csv',
              onChange: handleFileChange,
              'aria-label': 'Select CSV file to import',
